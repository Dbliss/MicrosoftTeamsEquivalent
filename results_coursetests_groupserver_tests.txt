============================= test session starts ==============================
platform linux -- Python 3.9.2, pytest-6.2.2, py-1.10.0, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/import/kamen/3/cs1531/project-automarking/tempstore/.hypothesis/examples')
metadata: {'Python': '3.9.2', 'Platform': 'Linux-4.19.0-21-amd64-x86_64-with-glibc2.31', 'Packages': {'pytest': '6.2.2', 'py': '1.10.0', 'pluggy': '0.13.1'}, 'Plugins': {'jest': '0.3.0', 'hypothesis': '6.1.1', 'timeout': '1.4.2', 'snapshottest': '0.6.0', 'metadata': '2.0.1'}}
rootdir: /import/kamen/3/cs1531/project-automarking/tempstore
plugins: jest-0.3.0, hypothesis-6.1.1, timeout-1.4.2, snapshottest-0.6.0, metadata-2.0.1
collecting ... collected 366 items

httpTests/adminTests/test_admin_user_remove.py::testOnceRemovedUserCantDoAnything FAILED [  0%]
httpTests/adminTests/test_admin_user_remove.py::testMessagesAfterUserRemovalCorrectFormat FAILED [  0%]
httpTests/adminTests/test_admin_user_remove.py::testRemovedProfileStillFetchableWithUserProfile FAILED [  0%]
httpTests/adminTests/test_admin_user_remove.py::testRemovalRemovedFromChannel FAILED [  1%]
httpTests/adminTests/test_admin_user_remove.py::testRemovalRemovedFromDm FAILED [  1%]
httpTests/adminTests/test_admin_user_remove.py::testRemovalNotInUsersAll FAILED [  1%]
httpTests/adminTests/test_admin_user_remove.py::testEmailReusable FAILED [  1%]
httpTests/adminTests/test_admin_user_remove.py::testHandleReusable FAILED [  2%]
httpTests/adminTests/test_admin_user_remove.py::testInvalidUser FAILED   [  2%]
httpTests/adminTests/test_admin_user_remove.py::testCannotRemoveLastOwner FAILED [  2%]
httpTests/adminTests/test_admin_user_remove.py::testCannotRemoveUserNonowner PASSED [  3%]
httpTests/adminTests/test_admin_user_remove.py::testInvalidToken PASSED  [  3%]
httpTests/adminTests/test_admin_userpermission_change.py::testSuccessfulPermissionChange FAILED [  3%]
httpTests/adminTests/test_admin_userpermission_change.py::testCannotDemoteLastOwner FAILED [  3%]
httpTests/adminTests/test_admin_userpermission_change.py::testNonownerCantChangePermissions PASSED [  4%]
httpTests/adminTests/test_admin_userpermission_change.py::testInvalidUser FAILED [  4%]
httpTests/adminTests/test_admin_userpermission_change.py::testInvalidPermission FAILED [  4%]
httpTests/adminTests/test_admin_userpermission_change.py::testSamePermission FAILED [  4%]
httpTests/adminTests/test_admin_userpermission_change.py::testInvalidToken PASSED [  5%]
httpTests/authTests/test_auth_login.py::testSuccessfulLogin PASSED       [  5%]
httpTests/authTests/test_auth_login.py::testCanHaveTwoSessions FAILED    [  5%]
httpTests/authTests/test_auth_login.py::testUnregisteredUser PASSED      [  6%]
httpTests/authTests/test_auth_login.py::testRegisteredButIncorrectPassword PASSED [  6%]
httpTests/authTests/test_auth_logout.py::testSuccessfulLogout PASSED     [  6%]
httpTests/authTests/test_auth_register.py::testInvalidEmail[@gmail.com] PASSED [  6%]
httpTests/authTests/test_auth_register.py::testInvalidEmail[bob] PASSED  [  7%]
httpTests/authTests/test_auth_register.py::testInvalidEmail[bob@bob@bob.com] PASSED [  7%]
httpTests/authTests/test_auth_register.py::testInvalidPassword[12345] PASSED [  7%]
httpTests/authTests/test_auth_register.py::testInvalidPassword[] PASSED  [  7%]
httpTests/authTests/test_auth_register.py::testInvalidNameFirst[] PASSED [  8%]
httpTests/authTests/test_auth_register.py::testInvalidNameFirst[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa] PASSED [  8%]
httpTests/authTests/test_auth_register.py::testInvalidNameLast[] PASSED  [  8%]
httpTests/authTests/test_auth_register.py::testInvalidNameLast[bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb] PASSED [  9%]
httpTests/authTests/test_auth_register.py::testDuplicateEmail PASSED     [  9%]
httpTests/authTests/test_auth_register.py::testRemovedUserName FAILED    [  9%]
httpTests/authTests/test_auth_register.py::testSuccessfulRegistration FAILED [  9%]
httpTests/authTests/test_auth_register.py::testBasicHandleGeneratedCorrectly[Bob-Smith-bobsmith] FAILED [ 10%]
httpTests/authTests/test_auth_register.py::testBasicHandleGeneratedCorrectly[ababababab-cdcdcdcdcdcd-abababababcdcdcdcdcd] FAILED [ 10%]
httpTests/authTests/test_auth_register.py::testDuplicateHandlesGeneratedCorrectly[abcdefghij-klmnopqrs-abcdefghijklmnopqrs-abcdefghij-klmnopqrs-abcdefghijklmnopqrs0] FAILED [ 10%]
httpTests/authTests/test_auth_register.py::testDuplicateHandlesGeneratedCorrectly[abcdefghij-klmnopqrst-abcdefghijklmnopqrst-abcdefghij-klmnopqrst-abcdefghijklmnopqrst0] FAILED [ 10%]
httpTests/authTests/test_auth_register.py::testDuplicateHandlesGeneratedCorrectly[@bcdefgh!j-klmn opqrst-bcdefghjklmnopqrst-bcdefghj-klmnopqrst-bcdefghjklmnopqrst0] FAILED [ 11%]
httpTests/authTests/test_auth_register.py::testDuplicateHandlesGeneratedCorrectly[abc-def0-abcdef0-abc-def-abcdef1] FAILED [ 11%]
httpTests/authTests/test_passwordreset_request.py::testReturnFormatCorrect FAILED [ 11%]
httpTests/authTests/test_passwordreset_request.py::testPasswordRequestLogsOutEverywhere FAILED [ 12%]
httpTests/authTests/test_passwordreset_reset.py::testInvalidPassword PASSED [ 12%]
httpTests/channelTests/test_channel_addowner.py::testChannelOwnerCanAddownerWhenMember FAILED [ 12%]
httpTests/channelTests/test_channel_addowner.py::testChannelOwnerCantAddownerWhenNonMember PASSED [ 12%]
httpTests/channelTests/test_channel_addowner.py::testNonMemberCannotAddOwner FAILED [ 13%]
httpTests/channelTests/test_channel_addowner.py::testGlobalOwnerNonMemberCantAddownerPrivate FAILED [ 13%]
httpTests/channelTests/test_channel_addowner.py::testGlobalOwnerNonMemberCantAddownerPublic FAILED [ 13%]
httpTests/channelTests/test_channel_addowner.py::testMemberCannotAddOwner PASSED [ 13%]
httpTests/channelTests/test_channel_addowner.py::testCannotAddownerPrexistingChannelOwner PASSED [ 14%]
httpTests/channelTests/test_channel_addowner.py::testWithInvalidUId PASSED [ 14%]
httpTests/channelTests/test_channel_addowner.py::testWithInvalidChannelId PASSED [ 14%]
httpTests/channelTests/test_channel_addowner.py::testInvalidToken PASSED [ 15%]
httpTests/channelTests/test_channel_details.py::testMemberSuccessful FAILED [ 15%]
httpTests/channelTests/test_channel_details.py::testNonMemberNotSuccessful FAILED [ 15%]
httpTests/channelTests/test_channel_details.py::testInvalidChannelId FAILED [ 15%]
httpTests/channelTests/test_channel_details.py::testInvalidToken FAILED  [ 16%]
httpTests/channelTests/test_channel_invite.py::testDuplicateInvite FAILED [ 16%]
httpTests/channelTests/test_channel_invite.py::testInviteGlobalOwner FAILED [ 16%]
httpTests/channelTests/test_channel_invite.py::testInviteGlobalMember FAILED [ 16%]
httpTests/channelTests/test_channel_invite.py::testInvitationFromNonChannelMember FAILED [ 17%]
httpTests/channelTests/test_channel_invite.py::testChannelIdInvalid FAILED [ 17%]
httpTests/channelTests/test_channel_invite.py::testUIdInvalid FAILED     [ 17%]
httpTests/channelTests/test_channel_invite.py::testInvalidatedToken FAILED [ 18%]
httpTests/channelTests/test_channel_join.py::testGlobalOwnerJoinChannelPublic FAILED [ 18%]
httpTests/channelTests/test_channel_join.py::testGlobalOwnerJoinChannelPrivate FAILED [ 18%]
httpTests/channelTests/test_channel_join.py::testGlobalMemberJoinPublic FAILED [ 18%]
httpTests/channelTests/test_channel_join.py::testGlobalMemberCantJoinPrivate PASSED [ 19%]
httpTests/channelTests/test_channel_join.py::testAlreadyJoinedChannel PASSED [ 19%]
httpTests/channelTests/test_channel_join.py::testJoinInvalidChannelId PASSED [ 19%]
httpTests/channelTests/test_channel_join.py::testInvalidatedToken PASSED [ 19%]
httpTests/channelTests/test_channel_leave.py::testMemberLeaveChannelSuccessfully FAILED [ 20%]
httpTests/channelTests/test_channel_leave.py::testLeaveChannelWhenNotMember FAILED [ 20%]
httpTests/channelTests/test_channel_leave.py::testInvalidChannelId FAILED [ 20%]
httpTests/channelTests/test_channel_leave.py::testInvalidToken FAILED    [ 21%]
httpTests/channelTests/test_channel_messages.py::testMessageTimestamp FAILED [ 21%]
httpTests/channelTests/test_channel_messages.py::testUnderFiftyMessagesSent FAILED [ 21%]
httpTests/channelTests/test_channel_messages.py::testOverFiftyMessagesSent FAILED [ 21%]
httpTests/channelTests/test_channel_messages.py::testRemovalByEditReflected FAILED [ 22%]
httpTests/channelTests/test_channel_messages.py::testRemovalByDeletionReflected FAILED [ 22%]
httpTests/channelTests/test_channel_messages.py::testInputErrorWhenStartGreaterThanMessageNum FAILED [ 22%]
httpTests/channelTests/test_channel_messages.py::testAccessErrorWhenUserIsNonMember FAILED [ 22%]
httpTests/channelTests/test_channel_messages.py::testInputErrorWhenChannelIdInvalid FAILED [ 23%]
httpTests/channelTests/test_channel_messages.py::testAccessErrorWhenInvalidTokenGiven FAILED [ 23%]
httpTests/channelTests/test_channel_removeowner.py::testOwnerCanRemoveOwner FAILED [ 23%]
httpTests/channelTests/test_channel_removeowner.py::testGlobalOwnerMmberCanRemoveOwner FAILED [ 24%]
httpTests/channelTests/test_channel_removeowner.py::testGlobalOwnerNonmemberCannotRemoveOwner FAILED [ 24%]
httpTests/channelTests/test_channel_removeowner.py::testNonmemberCannotRemoveOwner FAILED [ 24%]
httpTests/channelTests/test_channel_removeowner.py::testMmberCannotRemoveOwner FAILED [ 24%]
httpTests/channelTests/test_channel_removeowner.py::testCannotRemoveLastOwner PASSED [ 25%]
httpTests/channelTests/test_channel_removeowner.py::testGlobalOwnerCannotRemoveOnlyOwner PASSED [ 25%]
httpTests/channelTests/test_channel_removeowner.py::testCannotRemoveNonOwner PASSED [ 25%]
httpTests/channelTests/test_channel_removeowner.py::testInvalidUId PASSED [ 25%]
httpTests/channelTests/test_channel_removeowner.py::testWithInvalidChannelId PASSED [ 26%]
httpTests/channelTests/test_channel_removeowner.py::testInvalidatedToken PASSED [ 26%]
httpTests/channels_tests/test_channels_create.py::testCreateChannel[True-andys room] FAILED [ 26%]
httpTests/channels_tests/test_channels_create.py::testCreateChannel[False-andys room] FAILED [ 27%]
httpTests/channels_tests/test_channels_create.py::testInvalidChannelNameLength[True-] PASSED [ 27%]
httpTests/channels_tests/test_channels_create.py::testInvalidChannelNameLength[True-I AM NOT A TOY AND ALSO THIS NAME IS TOO LONG] PASSED [ 27%]
httpTests/channels_tests/test_channels_create.py::testInvalidChannelNameLength[False-] PASSED [ 27%]
httpTests/channels_tests/test_channels_create.py::testInvalidChannelNameLength[False-I AM NOT A TOY AND ALSO THIS NAME IS TOO LONG] PASSED [ 28%]
httpTests/channels_tests/test_channels_create.py::testInvalidatedToken PASSED [ 28%]
httpTests/channels_tests/test_channels_list.py::testWhenInNoChannels PASSED [ 28%]
httpTests/channels_tests/test_channels_list.py::testWhenInOneChannel[True-andy] PASSED [ 28%]
httpTests/channels_tests/test_channels_list.py::testWhenInOneChannel[False-andy] PASSED [ 29%]
httpTests/channels_tests/test_channels_list.py::testWhenInMultipleChannels[False-True-ZERG-andy] PASSED [ 29%]
httpTests/channels_tests/test_channels_list.py::testWhenInMultipleChannels[False-False-ZERG-andy] PASSED [ 29%]
httpTests/channels_tests/test_channels_list.py::testWhenInMultipleChannels[True-True-ZERG-andy] PASSED [ 30%]
httpTests/channels_tests/test_channels_list.py::testWhenInMultipleChannels[True-False-ZERG-andy] PASSED [ 30%]
httpTests/channels_tests/test_channels_list.py::testListAfterLeaveChannel FAILED [ 30%]
httpTests/channels_tests/test_channels_list.py::testInvalidatedToken PASSED [ 30%]
httpTests/channels_tests/test_channels_listall.py::testWhenNoChannels PASSED [ 31%]
httpTests/channels_tests/test_channels_listall.py::testWhenOneChannelExistsPrivate PASSED [ 31%]
httpTests/channels_tests/test_channels_listall.py::testWhenOneChannelExistsPublic PASSED [ 31%]
httpTests/channels_tests/test_channels_listall.py::testWhenMultipleChannelsExist PASSED [ 31%]
httpTests/channels_tests/test_channels_listall.py::testInvalidatedToken PASSED [ 32%]
httpTests/dmTests/test_dm_create.py::testSuccessfulDmCreation PASSED     [ 32%]
httpTests/dmTests/test_dm_create.py::testDmNameCreationMultiple FAILED   [ 32%]
httpTests/dmTests/test_dm_create.py::testDmToInvalidUsers PASSED         [ 33%]
httpTests/dmTests/test_dm_create.py::testDmToUsersButOneInvalid PASSED   [ 33%]
httpTests/dmTests/test_dm_create.py::testDmToUsersButDuplicate PASSED    [ 33%]
httpTests/dmTests/test_dm_create.py::testInvalidToken PASSED             [ 33%]
httpTests/dmTests/test_dm_details.py::testMemberSuccessful FAILED        [ 34%]
httpTests/dmTests/test_dm_details.py::testNonMemberNotSuccessful PASSED  [ 34%]
httpTests/dmTests/test_dm_details.py::testInvalidDmId PASSED             [ 34%]
httpTests/dmTests/test_dm_details.py::testInvalidToken PASSED            [ 34%]
httpTests/dmTests/test_dm_leave.py::testMemberLeaveDmSuccessfully PASSED [ 35%]
httpTests/dmTests/test_dm_leave.py::testLeaveDmWhenNotMember PASSED      [ 35%]
httpTests/dmTests/test_dm_leave.py::testInvalidDmId PASSED               [ 35%]
httpTests/dmTests/test_dm_leave.py::testInvalidToken PASSED              [ 36%]
httpTests/dmTests/test_dm_list.py::testWhenInNoDms PASSED                [ 36%]
httpTests/dmTests/test_dm_list.py::testWhenInOneDm PASSED                [ 36%]
httpTests/dmTests/test_dm_list.py::testWhenInMultipleDms PASSED          [ 36%]
httpTests/dmTests/test_dm_list.py::testListAfterLeaveDm PASSED           [ 37%]
httpTests/dmTests/test_dm_list.py::testInvalidatedToken PASSED           [ 37%]
httpTests/dmTests/test_dm_messages.py::testUnderFiftyMessagesSent PASSED [ 37%]
httpTests/dmTests/test_dm_messages.py::testOverFiftyMessagesSent PASSED  [ 37%]
httpTests/dmTests/test_dm_messages.py::testRemovalByEditReflected FAILED [ 38%]
httpTests/dmTests/test_dm_messages.py::testRemovalByDeletionReflected FAILED [ 38%]
httpTests/dmTests/test_dm_messages.py::testInputErrorWhenStartGreaterThanMessageNum PASSED [ 38%]
httpTests/dmTests/test_dm_messages.py::testAccessErrorWhenUserIsNonMember PASSED [ 39%]
httpTests/dmTests/test_dm_messages.py::testInputErrorWhenDmIdInvalid PASSED [ 39%]
httpTests/dmTests/test_dm_messages.py::testAccessErrorWhenInvalidTokenGiven PASSED [ 39%]
httpTests/dmTests/test_dm_remove.py::testSuccessfulDmRemoval PASSED      [ 39%]
httpTests/dmTests/test_dm_remove.py::testRemovalRemovesMessages PASSED   [ 40%]
httpTests/dmTests/test_dm_remove.py::testNonownerCannotRemoveDm PASSED   [ 40%]
httpTests/dmTests/test_dm_remove.py::testOwnerNonmemberCannotRemoveDm PASSED [ 40%]
httpTests/dmTests/test_dm_remove.py::testInvalidDmId PASSED              [ 40%]
httpTests/dmTests/test_dm_remove.py::testInvalidToken PASSED             [ 41%]
httpTests/messageTests/test_message_edit.py::testOriginalPosterCanEditMessageChannel FAILED [ 41%]
httpTests/messageTests/test_message_edit.py::testOriginalPosterCanEditMessageDm FAILED [ 41%]
httpTests/messageTests/test_message_edit.py::testGlobalOwnerCantEditMembersMessageDm FAILED [ 42%]
httpTests/messageTests/test_message_edit.py::testEmptyEditDeletesMessage FAILED [ 42%]
httpTests/messageTests/test_message_edit.py::testInvalidMessageLength FAILED [ 42%]
httpTests/messageTests/test_message_edit.py::testCannotEditDeletedMessage FAILED [ 42%]
httpTests/messageTests/test_message_edit.py::testNonownerNonposterCantEdit FAILED [ 43%]
httpTests/messageTests/test_message_edit.py::testInvalidToken FAILED     [ 43%]
httpTests/messageTests/test_message_meta.py::testMessageIdsUnique FAILED [ 43%]
httpTests/messageTests/test_message_meta.py::testMessageIdsUniqueIter3 FAILED [ 43%]
httpTests/messageTests/test_message_pin.py::testSuccessfulPinChannelOwnerInChannel FAILED [ 44%]
httpTests/messageTests/test_message_pin.py::testSuccessfulPinDmOwnerInDm PASSED [ 44%]
httpTests/messageTests/test_message_pin.py::testSuccessfulPinGlobalOwnerInChannel FAILED [ 44%]
httpTests/messageTests/test_message_pin.py::testInvalidMessageId PASSED  [ 45%]
httpTests/messageTests/test_message_pin.py::testCannotPinTwice FAILED    [ 45%]
httpTests/messageTests/test_message_pin.py::testChannelMemberCantPin FAILED [ 45%]
httpTests/messageTests/test_message_pin.py::testDmMemberCantPin PASSED   [ 45%]
httpTests/messageTests/test_message_pin.py::testGlobalOwnerCantPinInDm PASSED [ 46%]
httpTests/messageTests/test_message_pin.py::testNonmemberCantPin FAILED  [ 46%]
httpTests/messageTests/test_message_pin.py::testInvalidToken FAILED      [ 46%]
httpTests/messageTests/test_message_react.py::testSuccessfulReactInChannel FAILED [ 46%]
httpTests/messageTests/test_message_react.py::testSuccessfulReactToDmMessage PASSED [ 47%]
httpTests/messageTests/test_message_react.py::testInvalidMessageId PASSED [ 47%]
httpTests/messageTests/test_message_react.py::testInvalidReactId FAILED  [ 47%]
httpTests/messageTests/test_message_react.py::testCantReactTwice FAILED  [ 48%]
httpTests/messageTests/test_message_react.py::testNonmemberCannotReact FAILED [ 48%]
httpTests/messageTests/test_message_react.py::testInvalidToken FAILED    [ 48%]
httpTests/messageTests/test_message_remove.py::testOriginalPosterCanRemoveMessage FAILED [ 48%]
httpTests/messageTests/test_message_remove.py::testGlobalOwnerCantRemoveMembersMessageDm FAILED [ 49%]
httpTests/messageTests/test_message_remove.py::testCannotRemoveDeletedMessage FAILED [ 49%]
httpTests/messageTests/test_message_remove.py::testNonownerNonposterCantRemoveMessage FAILED [ 49%]
httpTests/messageTests/test_message_remove.py::testInvalidToken FAILED   [ 50%]
httpTests/messageTests/test_message_send.py::testValidMessage FAILED     [ 50%]
httpTests/messageTests/test_message_send.py::testNonmemberPost FAILED    [ 50%]
httpTests/messageTests/test_message_send.py::testInvalidChannel FAILED   [ 50%]
httpTests/messageTests/test_message_send.py::testInvalidMessage[] FAILED [ 51%]
httpTests/messageTests/test_message_send.py::testInvalidMessage[mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm] FAILED [ 51%]
httpTests/messageTests/test_message_send.py::testInvalidToken FAILED     [ 51%]
httpTests/messageTests/test_message_senddm.py::testValidMessage PASSED   [ 51%]
httpTests/messageTests/test_message_senddm.py::testNonmemberPost PASSED  [ 52%]
httpTests/messageTests/test_message_senddm.py::testInvalidDm PASSED      [ 52%]
httpTests/messageTests/test_message_senddm.py::testInvalidMessage[] PASSED [ 52%]
httpTests/messageTests/test_message_senddm.py::testInvalidMessage[mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm] PASSED [ 53%]
httpTests/messageTests/test_message_senddm.py::testInvalidToken PASSED   [ 53%]
httpTests/messageTests/test_message_sendlater.py::testValidFutureMessage FAILED [ 53%]
httpTests/messageTests/test_message_sendlater.py::testReturnsImmediately FAILED [ 53%]
httpTests/messageTests/test_message_sendlater.py::testInvalidReturnedIdUntilSent FAILED [ 54%]
httpTests/messageTests/test_message_sendlater.py::testNonmemberCannotSendlater PASSED [ 54%]
httpTests/messageTests/test_message_sendlater.py::testCannotTimeTravelAkaSendMessageInPast PASSED [ 54%]
httpTests/messageTests/test_message_sendlater.py::testInvalidMessage[] PASSED [ 54%]
httpTests/messageTests/test_message_sendlater.py::testInvalidMessage[mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm] PASSED [ 55%]
httpTests/messageTests/test_message_sendlater.py::testInvalidChannel PASSED [ 55%]
httpTests/messageTests/test_message_sendlater.py::testInvalidToken FAILED [ 55%]
httpTests/messageTests/test_message_sendlaterdm.py::testValidFutureMessage PASSED [ 56%]
httpTests/messageTests/test_message_sendlaterdm.py::testReturnsImmediately PASSED [ 56%]
httpTests/messageTests/test_message_sendlaterdm.py::testInvalidReturnedIdUntilSent FAILED [ 56%]
httpTests/messageTests/test_message_sendlaterdm.py::testNonmemberCannotSendlater PASSED [ 56%]
httpTests/messageTests/test_message_sendlaterdm.py::testCannotTimeTravelAkaSendMessageInPast PASSED [ 57%]
httpTests/messageTests/test_message_sendlaterdm.py::testInvalidMessage[] PASSED [ 57%]
httpTests/messageTests/test_message_sendlaterdm.py::testInvalidMessage[mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm] PASSED [ 57%]
httpTests/messageTests/test_message_sendlaterdm.py::testInvalidDm PASSED [ 57%]
httpTests/messageTests/test_message_sendlaterdm.py::testInvalidToken FAILED [ 58%]
httpTests/messageTests/test_message_share.py::testSuccessfulShareToChannel FAILED [ 58%]
httpTests/messageTests/test_message_share.py::testSuccessfulShareToDm PASSED [ 58%]
httpTests/messageTests/test_message_share.py::testSuccessfulCrossShare[True] FAILED [ 59%]
httpTests/messageTests/test_message_share.py::testSuccessfulCrossShare[False] FAILED [ 59%]
httpTests/messageTests/test_message_share.py::testCannotShareToUnjoinedDm FAILED [ 59%]
httpTests/messageTests/test_message_share.py::testCannotShareToUnjoinedChannel FAILED [ 59%]
httpTests/messageTests/test_message_share.py::testCannotShareFromUnjoinedChannel FAILED [ 60%]
httpTests/messageTests/test_message_share.py::testCannotShareFromUnjoinedDm PASSED [ 60%]
httpTests/messageTests/test_message_share.py::testInvalidOgMessageId PASSED [ 60%]
httpTests/messageTests/test_message_share.py::testInvalidMessageLength FAILED [ 60%]
httpTests/messageTests/test_message_share.py::testShareToInvalidChannelId PASSED [ 61%]
httpTests/messageTests/test_message_share.py::testShareToInvalidDmId FAILED [ 61%]
httpTests/messageTests/test_message_share.py::testInvalidToken FAILED    [ 61%]
httpTests/messageTests/test_message_unpin.py::testSuccessfulUnpinChannelOwnerInChannel FAILED [ 62%]
httpTests/messageTests/test_message_unpin.py::testSuccessfulUnpinDmOwnerInDm PASSED [ 62%]
httpTests/messageTests/test_message_unpin.py::testSuccessfulUnpinGlobalOwnerInChannel FAILED [ 62%]
httpTests/messageTests/test_message_unpin.py::testInvalidMessageId PASSED [ 62%]
httpTests/messageTests/test_message_unpin.py::testCannotUnpinTwice FAILED [ 63%]
httpTests/messageTests/test_message_unpin.py::testChannelMemberCantUnpin FAILED [ 63%]
httpTests/messageTests/test_message_unpin.py::testDmMemberCantUnpin PASSED [ 63%]
httpTests/messageTests/test_message_unpin.py::testGlobalOwnerCantUnpinInDm PASSED [ 63%]
httpTests/messageTests/test_message_unpin.py::testNonmemberCantUnpin FAILED [ 64%]
httpTests/messageTests/test_message_unpin.py::testInvalidToken FAILED    [ 64%]
httpTests/messageTests/test_message_unreact.py::testSuccessfulUnreactInChannel FAILED [ 64%]
httpTests/messageTests/test_message_unreact.py::testSuccessfulUnreactToDmMessage PASSED [ 65%]
httpTests/messageTests/test_message_unreact.py::testInvalidMessageId PASSED [ 65%]
httpTests/messageTests/test_message_unreact.py::testInvalidReactId FAILED [ 65%]
httpTests/messageTests/test_message_unreact.py::testCantUnreactTwice FAILED [ 65%]
httpTests/messageTests/test_message_unreact.py::testNonmemberCannotUnreact FAILED [ 66%]
httpTests/messageTests/test_message_unreact.py::testInvalidToken FAILED  [ 66%]
httpTests/otherTests/test_clear.py::testClearWorks FAILED                [ 66%]
httpTests/otherTests/test_notifications_get.py::testTagThruMessageSendTriggersNotification FAILED [ 66%]
httpTests/otherTests/test_notifications_get.py::testTagNotInChannel FAILED [ 67%]
httpTests/otherTests/test_notifications_get.py::testMultipleSameTagsOnlyOneNotification FAILED [ 67%]
httpTests/otherTests/test_notifications_get.py::testTagSelf FAILED       [ 67%]
httpTests/otherTests/test_notifications_get.py::testMultipleTags FAILED  [ 68%]
httpTests/otherTests/test_notifications_get.py::testTagThruMessageSenddmTriggersNotification FAILED [ 68%]
httpTests/otherTests/test_notifications_get.py::testTagThruMessageEditTriggersNotification FAILED [ 68%]
httpTests/otherTests/test_notifications_get.py::testTagThruMessageShareTriggersNotification FAILED [ 68%]
httpTests/otherTests/test_notifications_get.py::testTagThruMessageSendlaterTriggersNotification FAILED [ 69%]
httpTests/otherTests/test_notifications_get.py::testMessageSendlaterTagNotifiesWhenSent FAILED [ 69%]
httpTests/otherTests/test_notifications_get.py::testTagThruMessageSendlaterdmTriggersNotification FAILED [ 69%]
httpTests/otherTests/test_notifications_get.py::testTagNotificationMessagePreviewLength[a small message] FAILED [ 69%]
httpTests/otherTests/test_notifications_get.py::testTagNotificationMessagePreviewLength[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] FAILED [ 70%]
httpTests/otherTests/test_notifications_get.py::testReactTriggersNotification[ch] FAILED [ 70%]
httpTests/otherTests/test_notifications_get.py::testReactTriggersNotification[dm] FAILED [ 70%]
httpTests/otherTests/test_notifications_get.py::testAddThruChInviteTriggersNotification FAILED [ 71%]
httpTests/otherTests/test_notifications_get.py::testAddThruDmCreateTriggersNotification FAILED [ 71%]
httpTests/otherTests/test_notifications_get.py::testMostRecent_20NotificationsFetched FAILED [ 71%]
httpTests/otherTests/test_notifications_get.py::testInvalidToken PASSED  [ 71%]
httpTests/otherTests/test_search.py::testNoMatches PASSED                [ 72%]
httpTests/otherTests/test_search.py::testSingleMatch FAILED              [ 72%]
httpTests/otherTests/test_search.py::testCaseInsensitiveMatch FAILED     [ 72%]
httpTests/otherTests/test_search.py::testMultipleMatches FAILED          [ 72%]
httpTests/otherTests/test_search.py::testMultipleChannelsJoined FAILED   [ 73%]
httpTests/otherTests/test_search.py::testSearchIncludesOnlyJoinedChannels FAILED [ 73%]
httpTests/otherTests/test_search.py::testSearchMatchesMoreThanJustAuthorisedUser FAILED [ 73%]
httpTests/otherTests/test_search.py::testInvalidSearch[] PASSED          [ 74%]
httpTests/otherTests/test_search.py::testInvalidSearch[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa] PASSED [ 74%]
httpTests/otherTests/test_search.py::testInvalidToken PASSED             [ 74%]
httpTests/otherTests/test_users_all.py::testSuccessfulUsersAll FAILED    [ 74%]
httpTests/otherTests/test_users_all.py::testInvalidToken FAILED          [ 75%]
httpTests/standupTests/test_standup_active.py::testCorrectReturnFormat[True] FAILED [ 75%]
httpTests/standupTests/test_standup_active.py::testCorrectReturnFormat[False] PASSED [ 75%]
httpTests/standupTests/test_standup_active.py::testActiveStandup PASSED  [ 75%]
httpTests/standupTests/test_standup_active.py::testInactiveStandup PASSED [ 76%]
httpTests/standupTests/test_standup_active.py::testInvalidChannelId PASSED [ 76%]
httpTests/standupTests/test_standup_active.py::testInvalidToken PASSED   [ 76%]
httpTests/standupTests/test_standup_send.py::testMessagesBufferedAndDisplayedCorrectly FAILED [ 77%]
httpTests/standupTests/test_standup_send.py::testStandupSendsAfterLoggedOut FAILED [ 77%]
httpTests/standupTests/test_standup_send.py::testReturnFormat PASSED     [ 77%]
httpTests/standupTests/test_standup_send.py::testNonMemberCannotStandupSend PASSED [ 77%]
httpTests/standupTests/test_standup_send.py::testSendWhenStandupInactive PASSED [ 78%]
httpTests/standupTests/test_standup_send.py::testInvalidMessageLength PASSED [ 78%]
httpTests/standupTests/test_standup_send.py::testInvalidChannelId PASSED [ 78%]
httpTests/standupTests/test_standup_send.py::testInvalidToken PASSED     [ 78%]
httpTests/standupTests/test_standup_start.py::testStandupStartReturnFormat PASSED [ 79%]
httpTests/standupTests/test_standup_start.py::testStandupNoMessages FAILED [ 79%]
httpTests/standupTests/test_standup_start.py::testReturnsImmediately PASSED [ 79%]
httpTests/standupTests/test_standup_start.py::testStandupRestartableAfterLapse FAILED [ 80%]
httpTests/standupTests/test_standup_start.py::testStandupAffectsOnlyOneChannel PASSED [ 80%]
httpTests/standupTests/test_standup_start.py::testNonmemberCannotStartStandup PASSED [ 80%]
httpTests/standupTests/test_standup_start.py::testCannotStartStandupWhenAlreadyActive PASSED [ 80%]
httpTests/standupTests/test_standup_start.py::testInvalidStandupLength PASSED [ 81%]
httpTests/standupTests/test_standup_start.py::testInvalidChannelId PASSED [ 81%]
httpTests/standupTests/test_standup_start.py::testInvalidToken PASSED    [ 81%]
httpTests/statsTests/test_user_stats.py::testReturnTypeCorrect FAILED    [ 81%]
httpTests/statsTests/test_user_stats.py::testChannelsTrackedChannelsCreate PASSED [ 82%]
httpTests/statsTests/test_user_stats.py::testChannelsTrackedChannelJoin PASSED [ 82%]
httpTests/statsTests/test_user_stats.py::testChannelsTrackedChannelInvite FAILED [ 82%]
httpTests/statsTests/test_user_stats.py::testChannelsTrackedChannelLeave FAILED [ 83%]
httpTests/statsTests/test_user_stats.py::testSmsTrackedSmCreate FAILED   [ 83%]
httpTests/statsTests/test_user_stats.py::testSmsTrackedSmLeave ERROR     [ 83%]
httpTests/statsTests/test_user_stats.py::testSmsTrackedSmRemove ERROR    [ 83%]
httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageSend FAILED [ 84%]
httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageSendlater FAILED [ 84%]
httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageSenddm ERROR [ 84%]
httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageSenddmlater ERROR [ 84%]
httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageShare FAILED [ 85%]
httpTests/statsTests/test_user_stats.py::testMessagesTrackedStandupFinish PASSED [ 85%]
httpTests/statsTests/test_user_stats.py::testInvolvementTracked PASSED   [ 85%]
httpTests/statsTests/test_user_stats.py::testInvalidToken PASSED         [ 86%]
httpTests/statsTests/test_users_stats.py::testReturnTypeCorrect FAILED   [ 86%]
httpTests/statsTests/test_users_stats.py::testChannelsTrackedChannelsCreate PASSED [ 86%]
httpTests/statsTests/test_users_stats.py::testDmsTrackedDmCreate PASSED  [ 86%]
httpTests/statsTests/test_users_stats.py::testDmsTrackedDmRemove PASSED  [ 87%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageSend FAILED [ 87%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageSendlater FAILED [ 87%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageSenddm PASSED [ 87%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageSenddmlater FAILED [ 88%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageShare FAILED [ 88%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedStandupFinish PASSED [ 88%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedEditedToRemoval FAILED [ 89%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedDeleted FAILED [ 89%]
httpTests/statsTests/test_users_stats.py::testMessagesTrackedDmRemoved FAILED [ 89%]
httpTests/statsTests/test_users_stats.py::testUtilizationTracked PASSED  [ 89%]
httpTests/statsTests/test_users_stats.py::testInvalidToken PASSED        [ 90%]
httpTests/userTests/test_user_profile.py::testUserProfileValid FAILED    [ 90%]
httpTests/userTests/test_user_profile.py::testInvalidUser FAILED         [ 90%]
httpTests/userTests/test_user_profile.py::testInvalidToken FAILED        [ 90%]
httpTests/userTests/test_user_profile_setemail.py::testSuccessfulEmailChange FAILED [ 91%]
httpTests/userTests/test_user_profile_setemail.py::testCannotChangeToTakenEmail FAILED [ 91%]
httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[] FAILED [ 91%]
httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[bob] FAILED [ 92%]
httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[ab.com] FAILED [ 92%]
httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[@gmail.com] FAILED [ 92%]
httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[ab@ab@gmail.com] FAILED [ 92%]
httpTests/userTests/test_user_profile_setemail.py::testInvalidToken FAILED [ 93%]
httpTests/userTests/test_user_profile_sethandle.py::testSuccessfulHandleChange FAILED [ 93%]
httpTests/userTests/test_user_profile_sethandle.py::testCannotChangeToTakenHandle FAILED [ 93%]
httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[] FAILED [ 93%]
httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[a] FAILED [ 94%]
httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[aa] FAILED [ 94%]
httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[aaaaaaaaaaaaaaaaaaaaa] FAILED [ 94%]
httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[new handle] FAILED [ 95%]
httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[newh@ndle] FAILED [ 95%]
httpTests/userTests/test_user_profile_sethandle.py::testInvalidToken FAILED [ 95%]
httpTests/userTests/test_user_profile_setname.py::testUserProfileSetnameValidName FAILED [ 95%]
httpTests/userTests/test_user_profile_setname.py::testInvalidName[-] FAILED [ 96%]
httpTests/userTests/test_user_profile_setname.py::testInvalidName[-MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM] FAILED [ 96%]
httpTests/userTests/test_user_profile_setname.py::testInvalidName[PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP-] FAILED [ 96%]
httpTests/userTests/test_user_profile_setname.py::testInvalidName[PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP-MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM] FAILED [ 96%]
httpTests/userTests/test_user_profile_setname.py::testInvalidToken FAILED [ 97%]
httpTests/userTests/test_user_profile_uploadphoto.py::testReturnFormatCorrect FAILED [ 97%]
httpTests/userTests/test_user_profile_uploadphoto.py::testCannotUploadNonJpeg PASSED [ 97%]
httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidDimensions[-1000-0-0-0] FAILED [ 98%]
httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidDimensions[0--1000-0-0] ERROR [ 98%]
httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidDimensions[0-0--1000-0] ERROR [ 98%]
httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidDimensions[0-0-0--1000] ERROR [ 98%]
httpTests/userTests/test_user_profile_uploadphoto.py::testXEndLessThanStartValue ERROR [ 99%]
httpTests/userTests/test_user_profile_uploadphoto.py::testYEndLessThanStartValue ERROR [ 99%]
httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidUrl ERROR [ 99%]
httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidToken ERROR [100%]

====== Marks recorded: 77.60 ======


==================================== ERRORS ====================================
___________________ ERROR at setup of testSmsTrackedSmLeave ____________________
file /import/kamen/3/cs1531/project-automarking/tempstore/httpTests/statsTests/test_user_stats.py, line 96
  @iteration3
  def testSmsTrackedSmLeave(userWoody, woodyAndBuzzSm, ctx):
E       fixture 'woodyAndBuzzSm' not found
>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, channelFactory, ctx, dmFactory, doctest_namespace, img, include_metadata_in_junit_xml, messageFactory, metadata, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, snapshot, standupFactory, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, userBuzz, userFactory, userWoody, userZerg, woodyAndBuzzDm, woodysPublicToybox, zergsPrivateLair
>       use 'pytest --fixtures [testpath]' for help on them.

/import/kamen/3/cs1531/project-automarking/tempstore/httpTests/statsTests/test_user_stats.py:96
___________________ ERROR at setup of testSmsTrackedSmRemove ___________________
file /import/kamen/3/cs1531/project-automarking/tempstore/httpTests/statsTests/test_user_stats.py, line 107
  @iteration3
  def testSmsTrackedSmRemove(userWoody, userBuzz, woodyAndBuzzSm, ctx):
E       fixture 'woodyAndBuzzSm' not found
>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, channelFactory, ctx, dmFactory, doctest_namespace, img, include_metadata_in_junit_xml, messageFactory, metadata, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, snapshot, standupFactory, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, userBuzz, userFactory, userWoody, userZerg, woodyAndBuzzDm, woodysPublicToybox, zergsPrivateLair
>       use 'pytest --fixtures [testpath]' for help on them.

/import/kamen/3/cs1531/project-automarking/tempstore/httpTests/statsTests/test_user_stats.py:107
______________ ERROR at setup of testMessagesTrackedMessageSenddm ______________
file /import/kamen/3/cs1531/project-automarking/tempstore/httpTests/statsTests/test_user_stats.py, line 144
  @iteration3
  def testMessagesTrackedMessageSenddm(userWoody, woodyAndBuzzSm, messageFactory, ctx):
E       fixture 'woodyAndBuzzSm' not found
>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, channelFactory, ctx, dmFactory, doctest_namespace, img, include_metadata_in_junit_xml, messageFactory, metadata, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, snapshot, standupFactory, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, userBuzz, userFactory, userWoody, userZerg, woodyAndBuzzDm, woodysPublicToybox, zergsPrivateLair
>       use 'pytest --fixtures [testpath]' for help on them.

/import/kamen/3/cs1531/project-automarking/tempstore/httpTests/statsTests/test_user_stats.py:144
___________ ERROR at setup of testMessagesTrackedMessageSenddmlater ____________
file /import/kamen/3/cs1531/project-automarking/tempstore/httpTests/statsTests/test_user_stats.py, line 155
  @iteration3
  def testMessagesTrackedMessageSenddmlater(userWoody, woodyAndBuzzSm, messageFactory, ctx):
E       fixture 'woodyAndBuzzSm' not found
>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, channelFactory, ctx, dmFactory, doctest_namespace, img, include_metadata_in_junit_xml, messageFactory, metadata, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, snapshot, standupFactory, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, userBuzz, userFactory, userWoody, userZerg, woodyAndBuzzDm, woodysPublicToybox, zergsPrivateLair
>       use 'pytest --fixtures [testpath]' for help on them.

/import/kamen/3/cs1531/project-automarking/tempstore/httpTests/statsTests/test_user_stats.py:155
_____________ ERROR at setup of testInvalidDimensions[0--1000-0-0] _____________

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca47a186d0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca47a186d0>
conn = <urllib3.connection.HTTPConnection object at 0x7fca47a183d0>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None), read_timeout = None

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
                conn.request(method, url, **httplib_request_kw)
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            # Python 3
            pass
        except IOError as e:
            # Python 2 and macOS/Linux
            # EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE is needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            if e.errno not in {
                errno.EPIPE,
                errno.ESHUTDOWN,
                errno.EPROTOTYPE,
            }:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        # App Engine doesn't have a sock attr
        if getattr(conn, "sock", None):
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, "Read timed out. (read timeout=%s)" % read_timeout
                )
            if read_timeout is Timeout.DEFAULT_TIMEOUT:
                conn.sock.settimeout(socket.getdefaulttimeout())
            else:  # None or a value
                conn.sock.settimeout(read_timeout)
    
        # Receive the response from the server
        try:
            try:
                # Python 2.7, use buffering of HTTP responses
                httplib_response = conn.getresponse(buffering=True)
            except TypeError:
                # Python 3
                try:
                    httplib_response = conn.getresponse()
                except BaseException as e:
                    # Remove the TypeError from the exception chain in
                    # Python 3 (including for exceptions like SystemExit).
                    # Otherwise it looks like a bug in the code.
>                   six.raise_from(e, None)

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = None, from_value = None

>   ???

<string>:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca47a186d0>
conn = <urllib3.connection.HTTPConnection object at 0x7fca47a183d0>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None), read_timeout = None

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
                conn.request(method, url, **httplib_request_kw)
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            # Python 3
            pass
        except IOError as e:
            # Python 2 and macOS/Linux
            # EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE is needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            if e.errno not in {
                errno.EPIPE,
                errno.ESHUTDOWN,
                errno.EPROTOTYPE,
            }:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        # App Engine doesn't have a sock attr
        if getattr(conn, "sock", None):
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, "Read timed out. (read timeout=%s)" % read_timeout
                )
            if read_timeout is Timeout.DEFAULT_TIMEOUT:
                conn.sock.settimeout(socket.getdefaulttimeout())
            else:  # None or a value
                conn.sock.settimeout(read_timeout)
    
        # Receive the response from the server
        try:
            try:
                # Python 2.7, use buffering of HTTP responses
                httplib_response = conn.getresponse(buffering=True)
            except TypeError:
                # Python 3
                try:
>                   httplib_response = conn.getresponse()

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca47a183d0>

    def getresponse(self):
        """Get the response from the server.
    
        If the HTTPConnection is in the correct state, returns an
        instance of HTTPResponse or of whatever object is returned by
        the response_class variable.
    
        If a request has not been sent or if a previous response has
        not be handled, ResponseNotReady is raised.  If the HTTP
        response indicates that the connection should be closed, then
        it will be closed before the response is returned.  When the
        connection is closed, the underlying socket is closed.
        """
    
        # if a prior response has been completed, then forget about it.
        if self.__response and self.__response.isclosed():
            self.__response = None
    
        # if a prior response exists, then it must be completed (otherwise, we
        # cannot read this response's header to determine the connection-close
        # behavior)
        #
        # note: if a prior response existed, but was connection-close, then the
        # socket and response were made independent of this HTTPConnection
        # object since a new request requires that we open a whole new
        # connection
        #
        # this means the prior response had one of two states:
        #   1) will_close: this connection was reset and the prior socket and
        #                  response operate independently
        #   2) persistent: the response was retained and we await its
        #                  isclosed() status to become true.
        #
        if self.__state != _CS_REQ_SENT or self.__response:
            raise ResponseNotReady(self.__state)
    
        if self.debuglevel > 0:
            response = self.response_class(self.sock, self.debuglevel,
                                           method=self._method)
        else:
            response = self.response_class(self.sock, method=self._method)
    
        try:
            try:
>               response.begin()

/usr/lib/python3.9/http/client.py:1347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <http.client.HTTPResponse object at 0x7fca47a183a0>

    def begin(self):
        if self.headers is not None:
            # we've already started reading the response
            return
    
        # read until we get a non-100 response
        while True:
>           version, status, reason = self._read_status()

/usr/lib/python3.9/http/client.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <http.client.HTTPResponse object at 0x7fca47a183a0>

    def _read_status(self):
>       line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")

/usr/lib/python3.9/http/client.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <socket.SocketIO object at 0x7fca47a18430>
b = <memory at 0x7fca47f01f40>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        while True:
            try:
>               return self._sock.recv_into(b)
E               ConnectionResetError: [Errno 104] Connection reset by peer

/usr/lib/python3.9/socket.py:704: ConnectionResetError

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x7fca47a18970>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

../../.local/lib/python3.9/site-packages/requests/adapters.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca47a186d0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw["request_method"] = method
    
            # Import httplib's response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn't get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError("Cannot connect to proxy.", e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError("Connection aborted.", e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE', url = '/clear/v1', response = None
error = ProtocolError('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca47a186d0>
_stacktrace = <traceback object at 0x7fca47e685c0>

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
>               raise six.reraise(type(error), error, _stacktrace)

../../.local/lib/python3.9/site-packages/urllib3/util/retry.py:531: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tp = <class 'urllib3.exceptions.ProtocolError'>, value = None, tb = None

    def reraise(tp, value, tb=None):
        try:
            if value is None:
                value = tp()
            if value.__traceback__ is not tb:
>               raise value.with_traceback(tb)

../../.local/lib/python3.9/site-packages/urllib3/packages/six.py:734: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca47a186d0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca47a186d0>
conn = <urllib3.connection.HTTPConnection object at 0x7fca47a183d0>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None), read_timeout = None

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
                conn.request(method, url, **httplib_request_kw)
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            # Python 3
            pass
        except IOError as e:
            # Python 2 and macOS/Linux
            # EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE is needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            if e.errno not in {
                errno.EPIPE,
                errno.ESHUTDOWN,
                errno.EPROTOTYPE,
            }:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        # App Engine doesn't have a sock attr
        if getattr(conn, "sock", None):
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, "Read timed out. (read timeout=%s)" % read_timeout
                )
            if read_timeout is Timeout.DEFAULT_TIMEOUT:
                conn.sock.settimeout(socket.getdefaulttimeout())
            else:  # None or a value
                conn.sock.settimeout(read_timeout)
    
        # Receive the response from the server
        try:
            try:
                # Python 2.7, use buffering of HTTP responses
                httplib_response = conn.getresponse(buffering=True)
            except TypeError:
                # Python 3
                try:
                    httplib_response = conn.getresponse()
                except BaseException as e:
                    # Remove the TypeError from the exception chain in
                    # Python 3 (including for exceptions like SystemExit).
                    # Otherwise it looks like a bug in the code.
>                   six.raise_from(e, None)

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = None, from_value = None

>   ???

<string>:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca47a186d0>
conn = <urllib3.connection.HTTPConnection object at 0x7fca47a183d0>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None), read_timeout = None

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
                conn.request(method, url, **httplib_request_kw)
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            # Python 3
            pass
        except IOError as e:
            # Python 2 and macOS/Linux
            # EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE is needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            if e.errno not in {
                errno.EPIPE,
                errno.ESHUTDOWN,
                errno.EPROTOTYPE,
            }:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        # App Engine doesn't have a sock attr
        if getattr(conn, "sock", None):
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, "Read timed out. (read timeout=%s)" % read_timeout
                )
            if read_timeout is Timeout.DEFAULT_TIMEOUT:
                conn.sock.settimeout(socket.getdefaulttimeout())
            else:  # None or a value
                conn.sock.settimeout(read_timeout)
    
        # Receive the response from the server
        try:
            try:
                # Python 2.7, use buffering of HTTP responses
                httplib_response = conn.getresponse(buffering=True)
            except TypeError:
                # Python 3
                try:
>                   httplib_response = conn.getresponse()

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca47a183d0>

    def getresponse(self):
        """Get the response from the server.
    
        If the HTTPConnection is in the correct state, returns an
        instance of HTTPResponse or of whatever object is returned by
        the response_class variable.
    
        If a request has not been sent or if a previous response has
        not be handled, ResponseNotReady is raised.  If the HTTP
        response indicates that the connection should be closed, then
        it will be closed before the response is returned.  When the
        connection is closed, the underlying socket is closed.
        """
    
        # if a prior response has been completed, then forget about it.
        if self.__response and self.__response.isclosed():
            self.__response = None
    
        # if a prior response exists, then it must be completed (otherwise, we
        # cannot read this response's header to determine the connection-close
        # behavior)
        #
        # note: if a prior response existed, but was connection-close, then the
        # socket and response were made independent of this HTTPConnection
        # object since a new request requires that we open a whole new
        # connection
        #
        # this means the prior response had one of two states:
        #   1) will_close: this connection was reset and the prior socket and
        #                  response operate independently
        #   2) persistent: the response was retained and we await its
        #                  isclosed() status to become true.
        #
        if self.__state != _CS_REQ_SENT or self.__response:
            raise ResponseNotReady(self.__state)
    
        if self.debuglevel > 0:
            response = self.response_class(self.sock, self.debuglevel,
                                           method=self._method)
        else:
            response = self.response_class(self.sock, method=self._method)
    
        try:
            try:
>               response.begin()

/usr/lib/python3.9/http/client.py:1347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <http.client.HTTPResponse object at 0x7fca47a183a0>

    def begin(self):
        if self.headers is not None:
            # we've already started reading the response
            return
    
        # read until we get a non-100 response
        while True:
>           version, status, reason = self._read_status()

/usr/lib/python3.9/http/client.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <http.client.HTTPResponse object at 0x7fca47a183a0>

    def _read_status(self):
>       line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")

/usr/lib/python3.9/http/client.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <socket.SocketIO object at 0x7fca47a18430>
b = <memory at 0x7fca47f01f40>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        while True:
            try:
>               return self._sock.recv_into(b)
E               urllib3.exceptions.ProtocolError: ('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))

/usr/lib/python3.9/socket.py:704: ProtocolError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def ctx():
        if util.ISHTTPTEST:
            import requests
    
>           requests.delete(util.urls.CLEAR)

httpTests/fixtures.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.local/lib/python3.9/site-packages/requests/api.py:161: in delete
    return request('delete', url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:655: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fca47a18970>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
>           raise ConnectionError(err, request=request)
E           requests.exceptions.ConnectionError: ('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))

../../.local/lib/python3.9/site-packages/requests/adapters.py:498: ConnectionError
_____________ ERROR at setup of testInvalidDimensions[0-0--1000-0] _____________

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

../../.local/lib/python3.9/site-packages/urllib3/connection.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
>           raise err

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:86: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4772e820>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4772e820>
conn = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
>               conn.request(method, url, **httplib_request_kw)

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers=None):
        if headers is None:
            headers = {}
        else:
            # Avoid modifying the headers passed into .request()
            headers = headers.copy()
        if "user-agent" not in (six.ensure_str(k.lower()) for k in headers):
            headers["User-Agent"] = _get_default_user_agent()
>       super(HTTPConnection, self).request(method, url, body=body, headers=headers)

../../.local/lib/python3.9/site-packages/urllib3/connection.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        """Send a complete request to the server."""
>       self._send_request(method, url, body, headers, encode_chunked)

/usr/lib/python3.9/http/client.py:1255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if 'host' in header_names:
            skips['skip_host'] = 1
        if 'accept-encoding' in header_names:
            skips['skip_accept_encoding'] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if 'content-length' not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if 'transfer-encoding' not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel > 0:
                            print('Unable to determine size of %r' % body)
                        encode_chunked = True
                        self.putheader('Transfer-Encoding', 'chunked')
                else:
                    self.putheader('Content-Length', str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, 'body')
>       self.endheaders(body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>
message_body = None

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
>       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>
message_body = None, encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
>       self.send(msg)

/usr/lib/python3.9/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>
data = b'DELETE /clear/v1 HTTP/1.1\r\nHost: 127.0.0.1:48237\r\nUser-Agent: python-requests/2.25.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\nContent-Length: 0\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
>               self.connect()

/usr/lib/python3.9/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>

    def connect(self):
>       conn = self._new_conn()

../../.local/lib/python3.9/site-packages/urllib3/connection.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fca4772fb50>: Failed to establish a new connection: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/connection.py:181: NewConnectionError

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x7fca4772e6a0>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

../../.local/lib/python3.9/site-packages/requests/adapters.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4772e820>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw["request_method"] = method
    
            # Import httplib's response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn't get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError("Cannot connect to proxy.", e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError("Connection aborted.", e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE', url = '/clear/v1', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4772fb50>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4772e820>
_stacktrace = <traceback object at 0x7fca476a5780>

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
>           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4772fb50>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/urllib3/util/retry.py:573: MaxRetryError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def ctx():
        if util.ISHTTPTEST:
            import requests
    
>           requests.delete(util.urls.CLEAR)

httpTests/fixtures.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.local/lib/python3.9/site-packages/requests/api.py:161: in delete
    return request('delete', url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:655: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fca4772e6a0>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4772fb50>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/requests/adapters.py:516: ConnectionError
_____________ ERROR at setup of testInvalidDimensions[0-0-0--1000] _____________

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

../../.local/lib/python3.9/site-packages/urllib3/connection.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
>           raise err

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:86: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca476ab6d0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca476ab6d0>
conn = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
>               conn.request(method, url, **httplib_request_kw)

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers=None):
        if headers is None:
            headers = {}
        else:
            # Avoid modifying the headers passed into .request()
            headers = headers.copy()
        if "user-agent" not in (six.ensure_str(k.lower()) for k in headers):
            headers["User-Agent"] = _get_default_user_agent()
>       super(HTTPConnection, self).request(method, url, body=body, headers=headers)

../../.local/lib/python3.9/site-packages/urllib3/connection.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        """Send a complete request to the server."""
>       self._send_request(method, url, body, headers, encode_chunked)

/usr/lib/python3.9/http/client.py:1255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if 'host' in header_names:
            skips['skip_host'] = 1
        if 'accept-encoding' in header_names:
            skips['skip_accept_encoding'] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if 'content-length' not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if 'transfer-encoding' not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel > 0:
                            print('Unable to determine size of %r' % body)
                        encode_chunked = True
                        self.putheader('Transfer-Encoding', 'chunked')
                else:
                    self.putheader('Content-Length', str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, 'body')
>       self.endheaders(body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>
message_body = None

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
>       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>
message_body = None, encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
>       self.send(msg)

/usr/lib/python3.9/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>
data = b'DELETE /clear/v1 HTTP/1.1\r\nHost: 127.0.0.1:48237\r\nUser-Agent: python-requests/2.25.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\nContent-Length: 0\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
>               self.connect()

/usr/lib/python3.9/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>

    def connect(self):
>       conn = self._new_conn()

../../.local/lib/python3.9/site-packages/urllib3/connection.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca476ab310>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fca476ab310>: Failed to establish a new connection: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/connection.py:181: NewConnectionError

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x7fca476ab8e0>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

../../.local/lib/python3.9/site-packages/requests/adapters.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca476ab6d0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw["request_method"] = method
    
            # Import httplib's response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn't get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError("Cannot connect to proxy.", e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError("Connection aborted.", e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE', url = '/clear/v1', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca476ab310>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca476ab6d0>
_stacktrace = <traceback object at 0x7fca47aa7800>

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
>           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca476ab310>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/urllib3/util/retry.py:573: MaxRetryError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def ctx():
        if util.ISHTTPTEST:
            import requests
    
>           requests.delete(util.urls.CLEAR)

httpTests/fixtures.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.local/lib/python3.9/site-packages/requests/api.py:161: in delete
    return request('delete', url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:655: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fca476ab8e0>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca476ab310>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/requests/adapters.py:516: ConnectionError
_________________ ERROR at setup of testXEndLessThanStartValue _________________

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

../../.local/lib/python3.9/site-packages/urllib3/connection.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
>           raise err

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:86: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca478b2e50>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca478b2e50>
conn = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
>               conn.request(method, url, **httplib_request_kw)

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers=None):
        if headers is None:
            headers = {}
        else:
            # Avoid modifying the headers passed into .request()
            headers = headers.copy()
        if "user-agent" not in (six.ensure_str(k.lower()) for k in headers):
            headers["User-Agent"] = _get_default_user_agent()
>       super(HTTPConnection, self).request(method, url, body=body, headers=headers)

../../.local/lib/python3.9/site-packages/urllib3/connection.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        """Send a complete request to the server."""
>       self._send_request(method, url, body, headers, encode_chunked)

/usr/lib/python3.9/http/client.py:1255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if 'host' in header_names:
            skips['skip_host'] = 1
        if 'accept-encoding' in header_names:
            skips['skip_accept_encoding'] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if 'content-length' not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if 'transfer-encoding' not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel > 0:
                            print('Unable to determine size of %r' % body)
                        encode_chunked = True
                        self.putheader('Transfer-Encoding', 'chunked')
                else:
                    self.putheader('Content-Length', str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, 'body')
>       self.endheaders(body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>
message_body = None

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
>       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>
message_body = None, encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
>       self.send(msg)

/usr/lib/python3.9/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>
data = b'DELETE /clear/v1 HTTP/1.1\r\nHost: 127.0.0.1:48237\r\nUser-Agent: python-requests/2.25.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\nContent-Length: 0\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
>               self.connect()

/usr/lib/python3.9/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>

    def connect(self):
>       conn = self._new_conn()

../../.local/lib/python3.9/site-packages/urllib3/connection.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fca478b2a60>: Failed to establish a new connection: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/connection.py:181: NewConnectionError

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x7fca478b2100>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

../../.local/lib/python3.9/site-packages/requests/adapters.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca478b2e50>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw["request_method"] = method
    
            # Import httplib's response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn't get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError("Cannot connect to proxy.", e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError("Connection aborted.", e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE', url = '/clear/v1', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca478b2a60>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca478b2e50>
_stacktrace = <traceback object at 0x7fca475cc1c0>

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
>           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca478b2a60>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/urllib3/util/retry.py:573: MaxRetryError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def ctx():
        if util.ISHTTPTEST:
            import requests
    
>           requests.delete(util.urls.CLEAR)

httpTests/fixtures.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.local/lib/python3.9/site-packages/requests/api.py:161: in delete
    return request('delete', url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:655: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fca478b2100>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca478b2a60>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/requests/adapters.py:516: ConnectionError
_________________ ERROR at setup of testYEndLessThanStartValue _________________

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

../../.local/lib/python3.9/site-packages/urllib3/connection.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
>           raise err

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:86: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4787b610>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4787b610>
conn = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
>               conn.request(method, url, **httplib_request_kw)

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers=None):
        if headers is None:
            headers = {}
        else:
            # Avoid modifying the headers passed into .request()
            headers = headers.copy()
        if "user-agent" not in (six.ensure_str(k.lower()) for k in headers):
            headers["User-Agent"] = _get_default_user_agent()
>       super(HTTPConnection, self).request(method, url, body=body, headers=headers)

../../.local/lib/python3.9/site-packages/urllib3/connection.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        """Send a complete request to the server."""
>       self._send_request(method, url, body, headers, encode_chunked)

/usr/lib/python3.9/http/client.py:1255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if 'host' in header_names:
            skips['skip_host'] = 1
        if 'accept-encoding' in header_names:
            skips['skip_accept_encoding'] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if 'content-length' not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if 'transfer-encoding' not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel > 0:
                            print('Unable to determine size of %r' % body)
                        encode_chunked = True
                        self.putheader('Transfer-Encoding', 'chunked')
                else:
                    self.putheader('Content-Length', str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, 'body')
>       self.endheaders(body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>
message_body = None

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
>       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>
message_body = None, encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
>       self.send(msg)

/usr/lib/python3.9/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>
data = b'DELETE /clear/v1 HTTP/1.1\r\nHost: 127.0.0.1:48237\r\nUser-Agent: python-requests/2.25.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\nContent-Length: 0\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
>               self.connect()

/usr/lib/python3.9/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>

    def connect(self):
>       conn = self._new_conn()

../../.local/lib/python3.9/site-packages/urllib3/connection.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4787b730>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fca4787b730>: Failed to establish a new connection: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/connection.py:181: NewConnectionError

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x7fca4787be80>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

../../.local/lib/python3.9/site-packages/requests/adapters.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4787b610>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw["request_method"] = method
    
            # Import httplib's response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn't get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError("Cannot connect to proxy.", e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError("Connection aborted.", e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE', url = '/clear/v1', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4787b730>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4787b610>
_stacktrace = <traceback object at 0x7fca475729c0>

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
>           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4787b730>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/urllib3/util/retry.py:573: MaxRetryError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def ctx():
        if util.ISHTTPTEST:
            import requests
    
>           requests.delete(util.urls.CLEAR)

httpTests/fixtures.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.local/lib/python3.9/site-packages/requests/api.py:161: in delete
    return request('delete', url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:655: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fca4787be80>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4787b730>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/requests/adapters.py:516: ConnectionError
_______________________ ERROR at setup of testInvalidUrl _______________________

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

../../.local/lib/python3.9/site-packages/urllib3/connection.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
>           raise err

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:86: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca475c1520>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca475c1520>
conn = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
>               conn.request(method, url, **httplib_request_kw)

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers=None):
        if headers is None:
            headers = {}
        else:
            # Avoid modifying the headers passed into .request()
            headers = headers.copy()
        if "user-agent" not in (six.ensure_str(k.lower()) for k in headers):
            headers["User-Agent"] = _get_default_user_agent()
>       super(HTTPConnection, self).request(method, url, body=body, headers=headers)

../../.local/lib/python3.9/site-packages/urllib3/connection.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        """Send a complete request to the server."""
>       self._send_request(method, url, body, headers, encode_chunked)

/usr/lib/python3.9/http/client.py:1255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if 'host' in header_names:
            skips['skip_host'] = 1
        if 'accept-encoding' in header_names:
            skips['skip_accept_encoding'] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if 'content-length' not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if 'transfer-encoding' not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel > 0:
                            print('Unable to determine size of %r' % body)
                        encode_chunked = True
                        self.putheader('Transfer-Encoding', 'chunked')
                else:
                    self.putheader('Content-Length', str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, 'body')
>       self.endheaders(body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>
message_body = None

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
>       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>
message_body = None, encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
>       self.send(msg)

/usr/lib/python3.9/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>
data = b'DELETE /clear/v1 HTTP/1.1\r\nHost: 127.0.0.1:48237\r\nUser-Agent: python-requests/2.25.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\nContent-Length: 0\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
>               self.connect()

/usr/lib/python3.9/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>

    def connect(self):
>       conn = self._new_conn()

../../.local/lib/python3.9/site-packages/urllib3/connection.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca475c1160>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fca475c1160>: Failed to establish a new connection: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/connection.py:181: NewConnectionError

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x7fca475c1820>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

../../.local/lib/python3.9/site-packages/requests/adapters.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca475c1520>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw["request_method"] = method
    
            # Import httplib's response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn't get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError("Cannot connect to proxy.", e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError("Connection aborted.", e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE', url = '/clear/v1', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca475c1160>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca475c1520>
_stacktrace = <traceback object at 0x7fca475403c0>

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
>           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca475c1160>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/urllib3/util/retry.py:573: MaxRetryError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def ctx():
        if util.ISHTTPTEST:
            import requests
    
>           requests.delete(util.urls.CLEAR)

httpTests/fixtures.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.local/lib/python3.9/site-packages/requests/api.py:161: in delete
    return request('delete', url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:655: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fca475c1820>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca475c1160>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/requests/adapters.py:516: ConnectionError
______________________ ERROR at setup of testInvalidToken ______________________

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

../../.local/lib/python3.9/site-packages/urllib3/connection.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
>           raise err

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 48237), timeout = None, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/util/connection.py:86: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4772c2e0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
>           httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4772c2e0>
conn = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>
method = 'DELETE', url = '/clear/v1'
timeout = Timeout(connect=None, read=None, total=None), chunked = False
httplib_request_kw = {'body': None, 'headers': {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}}
timeout_obj = Timeout(connect=None, read=None, total=None)

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            if chunked:
                conn.request_chunked(method, url, **httplib_request_kw)
            else:
>               conn.request(method, url, **httplib_request_kw)

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers=None):
        if headers is None:
            headers = {}
        else:
            # Avoid modifying the headers passed into .request()
            headers = headers.copy()
        if "user-agent" not in (six.ensure_str(k.lower()) for k in headers):
            headers["User-Agent"] = _get_default_user_agent()
>       super(HTTPConnection, self).request(method, url, body=body, headers=headers)

../../.local/lib/python3.9/site-packages/urllib3/connection.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        """Send a complete request to the server."""
>       self._send_request(method, url, body, headers, encode_chunked)

/usr/lib/python3.9/http/client.py:1255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if 'host' in header_names:
            skips['skip_host'] = 1
        if 'accept-encoding' in header_names:
            skips['skip_accept_encoding'] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if 'content-length' not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if 'transfer-encoding' not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel > 0:
                            print('Unable to determine size of %r' % body)
                        encode_chunked = True
                        self.putheader('Transfer-Encoding', 'chunked')
                else:
                    self.putheader('Content-Length', str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, 'body')
>       self.endheaders(body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>
message_body = None

    def endheaders(self, message_body=None, *, encode_chunked=False):
        """Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.
        """
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
>       self._send_output(message_body, encode_chunked=encode_chunked)

/usr/lib/python3.9/http/client.py:1250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>
message_body = None, encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        """Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        """
        self._buffer.extend((b"", b""))
        msg = b"\r\n".join(self._buffer)
        del self._buffer[:]
>       self.send(msg)

/usr/lib/python3.9/http/client.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>
data = b'DELETE /clear/v1 HTTP/1.1\r\nHost: 127.0.0.1:48237\r\nUser-Agent: python-requests/2.25.1\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nConnection: keep-alive\r\nContent-Length: 0\r\n\r\n'

    def send(self, data):
        """Send `data' to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        """
    
        if self.sock is None:
            if self.auto_open:
>               self.connect()

/usr/lib/python3.9/http/client.py:950: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>

    def connect(self):
>       conn = self._new_conn()

../../.local/lib/python3.9/site-packages/urllib3/connection.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>: Failed to establish a new connection: [Errno 111] Connection refused

../../.local/lib/python3.9/site-packages/urllib3/connection.py:181: NewConnectionError

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x7fca4772c670>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
>               resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

../../.local/lib/python3.9/site-packages/requests/adapters.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4772c2e0>
method = 'DELETE', url = '/clear/v1', body = None
headers = {'User-Agent': 'python-requests/2.25.1', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=None, read=None, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None
response_kw = {'decode_content': False, 'preload_content': False}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/clear/v1', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
    
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get("preload_content", True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, "sock", None
            )
            if is_new_proxy_conn and http_tunnel_required:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw["request_method"] = method
    
            # Import httplib's response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except EmptyPoolError:
            # Didn't get a connection from the pool, no need to clean up
            clean_exit = True
            release_this_conn = False
            raise
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError("Cannot connect to proxy.", e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError("Connection aborted.", e)
    
>           retries = retries.increment(
                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

../../.local/lib/python3.9/site-packages/urllib3/connectionpool.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'DELETE', url = '/clear/v1', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>: Failed to establish a new connection: [Errno 111] Connection refused')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x7fca4772c2e0>
_stacktrace = <traceback object at 0x7fca4775ce40>

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
>           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/urllib3/util/retry.py:573: MaxRetryError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def ctx():
        if util.ISHTTPTEST:
            import requests
    
>           requests.delete(util.urls.CLEAR)

httpTests/fixtures.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.local/lib/python3.9/site-packages/requests/api.py:161: in delete
    return request('delete', url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/api.py:61: in request
    return session.request(method=method, url=url, **kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:542: in request
    resp = self.send(prep, **send_kwargs)
../../.local/lib/python3.9/site-packages/requests/sessions.py:655: in send
    r = adapter.send(request, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7fca4772c670>
request = <PreparedRequest [DELETE]>, stream = False
timeout = Timeout(connect=None, read=None, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or 'Content-Length' in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = ("Invalid timeout {}. Pass a (connect, read) "
                       "timeout tuple, or a single float to set "
                       "both timeouts to the same value".format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=48237): Max retries exceeded with url: /clear/v1 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7fca4772c1c0>: Failed to establish a new connection: [Errno 111] Connection refused'))

../../.local/lib/python3.9/site-packages/requests/adapters.py:516: ConnectionError
=================================== FAILURES ===================================
______________________ testOnceRemovedUserCantDoAnything _______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1499041326777, token='68c36d9c1d92c1012388159c2d5749c08f0ef4d57cf8e4be1f0d8f5d5959939d', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1262459475855, token='f1cda231aca37182cad53f76cf5412d8d01c90b8a2bc5927db75ea0cc7a48911', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=427575668923, ownerMembers=[1499041326777], allMembers=[])
ctx = None

    @iteration3
    def testOnceRemovedUserCantDoAnything(userWoody, userZerg, woodysPublicToybox, ctx):
>       adminUserRemove(userWoody.token, userZerg.uId, ctx)

httpTests/adminTests/test_admin_user_remove.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
__________________ testMessagesAfterUserRemovalCorrectFormat ___________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=721033933219, token='19903ad882785329a9b09506e07e5c8b698b0499dc42e4e16ab69937f1dda654', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1299085057196, token='ff312a6089eaa41e7a60f2f6ab2a2cd8972e980e6c602b635ab8ff46df9b5ea0', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=82805199674, ownerMembers=[721033933219], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c9c310>
ctx = None

    @iteration3
    def testMessagesAfterUserRemovalCorrectFormat(userWoody, userZerg, woodysPublicToybox, messageFactory, ctx):
        channelJoin(userZerg.token, woodysPublicToybox.channelId, ctx)
>       messageFactory(userZerg, woodysPublicToybox, 'hi')

httpTests/adminTests/test_admin_user_remove.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________ testRemovedProfileStillFetchableWithUserProfile ________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=415116475393, token='ce0acd999d72109de6d30ef5ae5a5e55ef681cfb84d212dd0712a12de5a4b001', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=24970111819, token='413394ef55ef64d99d3af458e105a36a81eb2ee76b54939b71189e849e7860f8', handleStr='')
ctx = None

    @iteration3
    def testRemovedProfileStillFetchableWithUserProfile(userWoody, userZerg, ctx):
>       adminUserRemove(userWoody.token, userZerg.uId, ctx)

httpTests/adminTests/test_admin_user_remove.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
________________________ testRemovalRemovedFromChannel _________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1391911332011, token='be00a41c47d0d4e22d22ee93c5a108ecad2c6bfb54aa7cac311d1559f6fddf35', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1250594675549, token='21554ac1b63d20cbed61fa6a514c4bc025a96154a9afbd10aae6fd1f15c8faf3', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1086507656800, ownerMembers=[1391911332011], allMembers=[])
ctx = None

    @iteration3
    def testRemovalRemovedFromChannel(userWoody, userZerg, woodysPublicToybox, ctx):
        channelJoin(userZerg.token, woodysPublicToybox.channelId, ctx)
    
>       adminUserRemove(userWoody.token, userZerg.uId, ctx)

httpTests/adminTests/test_admin_user_remove.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
___________________________ testRemovalRemovedFromDm ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=530279940871, token='4046f240cc505332a0c76df85b42deda0c44297793c66c14d7f1eda733b23205', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=194650361035, token='7e806aa86c740b19c872fc8181c818dc041a764cb74855c364f0fa7a12b4e1b9', handleStr='')
woodyAndBuzzDm = DM(owner=530279940871, members=[194650361035], name="'buzzlightyear, sheriffwoody'", dmId=1537311672273)
ctx = None

    @iteration3
    def testRemovalRemovedFromDm(userWoody, userBuzz, woodyAndBuzzDm, ctx):
>       adminUserRemove(userWoody.token, userBuzz.uId, ctx)

httpTests/adminTests/test_admin_user_remove.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
___________________________ testRemovalNotInUsersAll ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=658349134284, token='097285506209d7be5fbfc5bf8a8332ddf7698459f37924f4e80b12e4871aca63', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1393976956799, token='b8e0d6d2a638158f5084168af210a4c44253b77916bfb3d2b5d2b53f97974cf0', handleStr='')
ctx = None

    @iteration3
    def testRemovalNotInUsersAll(userWoody, userZerg, ctx):
>       adminUserRemove(userWoody.token, userZerg.uId, ctx)

httpTests/adminTests/test_admin_user_remove.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
______________________________ testEmailReusable _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=41899141883, token='fa8c1e8af20d2acf7525c3d630f7f27ae7324f406b6e7dd4bffef16b7482e435', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=947126881847, token='9e8ab36d5d2117d6ef18e6ca1c6663d0edff493acbc37f9615546244d9ec85c3', handleStr='')
ctx = None

    @iteration3
    def testEmailReusable(userWoody, userZerg, ctx):
>       adminUserRemove(userWoody.token, userZerg.uId, ctx)

httpTests/adminTests/test_admin_user_remove.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
______________________________ testHandleReusable ______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1491499648755, token='b2635d004bf6d70dd0d16b7426ea4b6d84d2f1e176a6a0bcb90f62115edb2b20', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=739746597961, token='b85af2480eda446a03bb9a8ec30f3119956572a384d4e9aa81b1be135b404de8', handleStr='')
ctx = None

    @iteration3
    def testHandleReusable(userWoody, userZerg, ctx):
>       adminUserRemove(userWoody.token, userZerg.uId, ctx)

httpTests/adminTests/test_admin_user_remove.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
_______________________________ testInvalidUser ________________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1077447423794, token='39395cac04b2e8a38ea7eaba4ad1ff9f1d3441e89a3f56aac293f71094d9838d', handleStr='')
ctx = None

    @iteration3
    def testInvalidUser(userWoody, ctx):
        with pytest.raises(InputError):
>           adminUserRemove(userWoody.token, -1, ctx)

httpTests/adminTests/test_admin_user_remove.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
__________________________ testCannotRemoveLastOwner ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=960257306363, token='b4c3412b24d8749371320bc6e1b8acda567157f775d79bb5bbab1fe1e82a9c7a', handleStr='')
ctx = None

    @iteration3
    def testCannotRemoveLastOwner(userWoody, ctx):
        with pytest.raises(InputError):
>           adminUserRemove(userWoody.token, userWoody.uId, ctx)

httpTests/adminTests/test_admin_user_remove.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:12: in adminUserRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
________________________ testSuccessfulPermissionChange ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1264676356833, token='83b196219b0864db54d6a23a7cf0c83dc22d9aaf75b2aaa6dea6cba5bcd2b877', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1351356075863, token='db0bed2acfc5adb16aafc904145d026215db6598e2a16ef5827766514afd8be7', handleStr='')
ctx = None

    @iteration3
    def testSuccessfulPermissionChange(userWoody, userBuzz, ctx):
>       adminUserpermissionChange(userWoody.token, userBuzz.uId, Permissions.DREAMSOWNER, ctx)

httpTests/adminTests/test_admin_userpermission_change.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:23: in adminUserpermissionChange
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
__________________________ testCannotDemoteLastOwner ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=333950062740, token='a6a898e888106e631339fb20cb840efb3db7c69e93d1d1e3ff539bc73ff887e1', handleStr='')
ctx = None

    @iteration3
    def testCannotDemoteLastOwner(userWoody, ctx):
        with pytest.raises(InputError):
>           adminUserpermissionChange(userWoody.token, userWoody.uId, Permissions.DREAMSMEMBER, ctx)

httpTests/adminTests/test_admin_userpermission_change.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:23: in adminUserpermissionChange
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
_______________________________ testInvalidUser ________________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=982206294846, token='7e01f65c7bf156652960702813851fc88e9fd46fe87b6cf854fafd9d1b938dbd', handleStr='')
ctx = None

    @iteration3
    def testInvalidUser(userWoody, ctx):
        with pytest.raises(InputError):
>           adminUserpermissionChange(userWoody.token, -1, Permissions.DREAMSOWNER, ctx)

httpTests/adminTests/test_admin_userpermission_change.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:23: in adminUserpermissionChange
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
____________________________ testInvalidPermission _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=38527717247, token='f36bd05b8403d10e1e17de75c7b409e109fe030eda703ff6d4bf57efa82edbc4', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=902681135392, token='37775e8ac6861371074d8d0339106369e94f2c81863d05d139b0cf22da09119b', handleStr='')
ctx = None

    @iteration3
    def testInvalidPermission(userWoody, userBuzz, ctx):
        with pytest.raises(InputError):
>           adminUserpermissionChange(userWoody.token, userBuzz.uId, 1531, ctx)

httpTests/adminTests/test_admin_userpermission_change.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:23: in adminUserpermissionChange
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
______________________________ testSamePermission ______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=786297359774, token='dc2cd3881dc87e1fed5b8685307375b7697157f0b78574d0283eb37af9bd70b2', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=24931309781, token='2374837f084a9290a11aad8a9e9afba5d38202854f69ed2e7959ce8666cd5876', handleStr='')
ctx = None

    @iteration3
    def testSamePermission(userWoody, userBuzz, ctx):
        with pytest.raises(InputError):
>           adminUserpermissionChange(userWoody.token, userBuzz.uId, Permissions.DREAMSMEMBER, ctx)

httpTests/adminTests/test_admin_userpermission_change.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/admin.py:23: in adminUserpermissionChange
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [403]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
>           raise error.AccessError()
E           httpTests.error.AccessError: 403 Forbidden: None

httpTests/fakepi/util.py:95: AccessError
____________________________ testCanHaveTwoSessions ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1212498077992, token='64ba409975228732793755bf7f118245a892d8eef25ff867e50f0dbef519bc80', handleStr='')
ctx = None

    @pytest.mark.overrideMarks(2)
    def testCanHaveTwoSessions(userWoody, ctx):
        session2 = authLogin(userWoody.email, userWoody.password, ctx)
    
        # succeeds
>       assert userProfile(session2['token'], userWoody.uId, ctx) == userProfile(userWoody.token, userWoody.uId, ctx)

httpTests/authTests/test_auth_login.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testRemovedUserName ______________________________

ctx = None

    def testRemovedUserName(ctx):
        session = authRegister('abc@gmail.com', 'password1', 'Removed', 'user', ctx)
>       profile = userProfile(session['token'], session['authUserId'], ctx)['user']

httpTests/authTests/test_auth_register.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testSuccessfulRegistration __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=365853587830, token='419310473fefb091f4fb0218da3044f67777691bb88e87aadf8526e9f1f14060', handleStr='')
ctx = None

    def testSuccessfulRegistration(userWoody, ctx):
>       woodyProf = userProfile(userWoody.token, userWoody.uId, ctx)['user']

httpTests/authTests/test_auth_register.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________ testBasicHandleGeneratedCorrectly[Bob-Smith-bobsmith] _____________

nameFirst = 'Bob', nameLast = 'Smith', expectedHandle = 'bobsmith', ctx = None

    @pytest.mark.parametrize('nameFirst, nameLast, expectedHandle', [
        ('Bob', 'Smith', 'bobsmith'),
        ('ab' * 5, 'cd' * 6, f'{"ab" * 5}{"cd" * 5}')
    ])
    def testBasicHandleGeneratedCorrectly(nameFirst, nameLast, expectedHandle, ctx):
        session = authRegister('bob.jane@gmail.com', '~~qazwsx', nameFirst, nameLast, ctx)
    
>       actualHandle = userProfile(session['token'], session['authUserId'], ctx)['user']['handleStr']

httpTests/authTests/test_auth_register.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_ testBasicHandleGeneratedCorrectly[ababababab-cdcdcdcdcdcd-abababababcdcdcdcdcd] _

nameFirst = 'ababababab', nameLast = 'cdcdcdcdcdcd'
expectedHandle = 'abababababcdcdcdcdcd', ctx = None

    @pytest.mark.parametrize('nameFirst, nameLast, expectedHandle', [
        ('Bob', 'Smith', 'bobsmith'),
        ('ab' * 5, 'cd' * 6, f'{"ab" * 5}{"cd" * 5}')
    ])
    def testBasicHandleGeneratedCorrectly(nameFirst, nameLast, expectedHandle, ctx):
        session = authRegister('bob.jane@gmail.com', '~~qazwsx', nameFirst, nameLast, ctx)
    
>       actualHandle = userProfile(session['token'], session['authUserId'], ctx)['user']['handleStr']

httpTests/authTests/test_auth_register.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_ testDuplicateHandlesGeneratedCorrectly[abcdefghij-klmnopqrs-abcdefghijklmnopqrs-abcdefghij-klmnopqrs-abcdefghijklmnopqrs0] _

first1 = 'abcdefghij', last1 = 'klmnopqrs', handle1 = 'abcdefghijklmnopqrs'
first2 = 'abcdefghij', last2 = 'klmnopqrs', handle2 = 'abcdefghijklmnopqrs0'
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1631448294550, ownerMembers=[1091969121143], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1091969121143, token='1c5760258101ed4ba4eaee614cd08947e0dcf33e7622757e15db29499da675bd', handleStr='')
ctx = None

    @pytest.mark.parametrize('first1, last1, handle1, first2, last2, handle2', [
        ('abcdefghij', 'klmnopqrs', 'abcdefghijklmnopqrs', 'abcdefghij', 'klmnopqrs', 'abcdefghijklmnopqrs0'),
        ('abcdefghij', 'klmnopqrst', 'abcdefghijklmnopqrst', 'abcdefghij', 'klmnopqrst', 'abcdefghijklmnopqrst0'),
        ('@bcdefgh!j', 'klmn opqrst', 'bcdefghjklmnopqrst', 'bcdefghj', 'klmnopqrst', 'bcdefghjklmnopqrst0'),
        ('abc', 'def0', 'abcdef0', 'abc', 'def', 'abcdef1'),
    ])
    def testDuplicateHandlesGeneratedCorrectly(first1, last1, handle1, first2, last2, handle2, woodysPublicToybox, userWoody, ctx):
        email1 = 'blah1@email.com'
        email2 = 'blah2@email.com'
    
        authRegister('blah3@email.com', 'password1', 'abc', 'def', ctx)
    
        user1 = authRegister(email1, 'password1', first1, last1, ctx)
>       assert handle1 == userProfile(user1['token'], user1['authUserId'], ctx)['user']['handleStr']

httpTests/authTests/test_auth_register.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_ testDuplicateHandlesGeneratedCorrectly[abcdefghij-klmnopqrst-abcdefghijklmnopqrst-abcdefghij-klmnopqrst-abcdefghijklmnopqrst0] _

first1 = 'abcdefghij', last1 = 'klmnopqrst', handle1 = 'abcdefghijklmnopqrst'
first2 = 'abcdefghij', last2 = 'klmnopqrst', handle2 = 'abcdefghijklmnopqrst0'
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=801938029320, ownerMembers=[714371678558], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=714371678558, token='7d9ee5cc450c35fc19b5df537d1b2cbecfa418066fa11cdc316ce914f6d6ebf7', handleStr='')
ctx = None

    @pytest.mark.parametrize('first1, last1, handle1, first2, last2, handle2', [
        ('abcdefghij', 'klmnopqrs', 'abcdefghijklmnopqrs', 'abcdefghij', 'klmnopqrs', 'abcdefghijklmnopqrs0'),
        ('abcdefghij', 'klmnopqrst', 'abcdefghijklmnopqrst', 'abcdefghij', 'klmnopqrst', 'abcdefghijklmnopqrst0'),
        ('@bcdefgh!j', 'klmn opqrst', 'bcdefghjklmnopqrst', 'bcdefghj', 'klmnopqrst', 'bcdefghjklmnopqrst0'),
        ('abc', 'def0', 'abcdef0', 'abc', 'def', 'abcdef1'),
    ])
    def testDuplicateHandlesGeneratedCorrectly(first1, last1, handle1, first2, last2, handle2, woodysPublicToybox, userWoody, ctx):
        email1 = 'blah1@email.com'
        email2 = 'blah2@email.com'
    
        authRegister('blah3@email.com', 'password1', 'abc', 'def', ctx)
    
        user1 = authRegister(email1, 'password1', first1, last1, ctx)
>       assert handle1 == userProfile(user1['token'], user1['authUserId'], ctx)['user']['handleStr']

httpTests/authTests/test_auth_register.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_ testDuplicateHandlesGeneratedCorrectly[@bcdefgh!j-klmn opqrst-bcdefghjklmnopqrst-bcdefghj-klmnopqrst-bcdefghjklmnopqrst0] _

first1 = '@bcdefgh!j', last1 = 'klmn opqrst', handle1 = 'bcdefghjklmnopqrst'
first2 = 'bcdefghj', last2 = 'klmnopqrst', handle2 = 'bcdefghjklmnopqrst0'
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=894249808205, ownerMembers=[1409492790905], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1409492790905, token='544dd7926a7cb1358f12042b84cf5d8fb40bac07cbcbb5c65e03a01e46f6c488', handleStr='')
ctx = None

    @pytest.mark.parametrize('first1, last1, handle1, first2, last2, handle2', [
        ('abcdefghij', 'klmnopqrs', 'abcdefghijklmnopqrs', 'abcdefghij', 'klmnopqrs', 'abcdefghijklmnopqrs0'),
        ('abcdefghij', 'klmnopqrst', 'abcdefghijklmnopqrst', 'abcdefghij', 'klmnopqrst', 'abcdefghijklmnopqrst0'),
        ('@bcdefgh!j', 'klmn opqrst', 'bcdefghjklmnopqrst', 'bcdefghj', 'klmnopqrst', 'bcdefghjklmnopqrst0'),
        ('abc', 'def0', 'abcdef0', 'abc', 'def', 'abcdef1'),
    ])
    def testDuplicateHandlesGeneratedCorrectly(first1, last1, handle1, first2, last2, handle2, woodysPublicToybox, userWoody, ctx):
        email1 = 'blah1@email.com'
        email2 = 'blah2@email.com'
    
        authRegister('blah3@email.com', 'password1', 'abc', 'def', ctx)
    
        user1 = authRegister(email1, 'password1', first1, last1, ctx)
>       assert handle1 == userProfile(user1['token'], user1['authUserId'], ctx)['user']['handleStr']

httpTests/authTests/test_auth_register.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___ testDuplicateHandlesGeneratedCorrectly[abc-def0-abcdef0-abc-def-abcdef1] ___

first1 = 'abc', last1 = 'def0', handle1 = 'abcdef0', first2 = 'abc'
last2 = 'def', handle2 = 'abcdef1'
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=941478385589, ownerMembers=[374612362042], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=374612362042, token='35f7d111771aaf2d80e1920ab7c5ee4dd1f89f04a0de72af5a480a2eee77d278', handleStr='')
ctx = None

    @pytest.mark.parametrize('first1, last1, handle1, first2, last2, handle2', [
        ('abcdefghij', 'klmnopqrs', 'abcdefghijklmnopqrs', 'abcdefghij', 'klmnopqrs', 'abcdefghijklmnopqrs0'),
        ('abcdefghij', 'klmnopqrst', 'abcdefghijklmnopqrst', 'abcdefghij', 'klmnopqrst', 'abcdefghijklmnopqrst0'),
        ('@bcdefgh!j', 'klmn opqrst', 'bcdefghjklmnopqrst', 'bcdefghj', 'klmnopqrst', 'bcdefghjklmnopqrst0'),
        ('abc', 'def0', 'abcdef0', 'abc', 'def', 'abcdef1'),
    ])
    def testDuplicateHandlesGeneratedCorrectly(first1, last1, handle1, first2, last2, handle2, woodysPublicToybox, userWoody, ctx):
        email1 = 'blah1@email.com'
        email2 = 'blah2@email.com'
    
        authRegister('blah3@email.com', 'password1', 'abc', 'def', ctx)
    
        user1 = authRegister(email1, 'password1', first1, last1, ctx)
>       assert handle1 == userProfile(user1['token'], user1['authUserId'], ctx)['user']['handleStr']

httpTests/authTests/test_auth_register.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testReturnFormatCorrect ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=365161046010, token='d015d280d614bb9a8fa14a10d385f576d391292dbd6b865fb9e07d73facea794', handleStr='')
ctx = None

    @iteration3
    def testReturnFormatCorrect(userWoody, ctx):
        assert authPasswordresetRequest(userWoody.email, ctx) == {}
>       assert authPasswordresetRequest("invalid@email.com", ctx) == {}

httpTests/authTests/test_passwordreset_request.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/auth.py:46: in authPasswordresetRequest
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [500]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [500]>

httpTests/fakepi/util.py:97: Exception
_____________________ testPasswordRequestLogsOutEverywhere _____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=547801505715, token='ecce7a6da45f9969763d87a6db3dd9dda7ff36fd2fdd6c54204b47e7433dbd71', handleStr='')
ctx = None

    @iteration3
    def testPasswordRequestLogsOutEverywhere(userWoody, ctx):
        sess2 = authLogin(userWoody.email, userWoody.password, ctx)
    
        authPasswordresetRequest(userWoody.email, ctx)
    
        with pytest.raises(AccessError):
>           usersAll(userWoody.token, ctx)

httpTests/authTests/test_passwordreset_request.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/other.py:11: in usersAll
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________ testChannelOwnerCanAddownerWhenMember _____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=766091050890, token='51c7d4b94405cc0e1cac9e4dce3b39091262728eafaa4ee4a7ec84df8168971c', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=851420574245, ownerMembers=[766091050890], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1305464301219, token='8389139df93c37cd0b436321588bf41a2dd9f67a5371f0c94e678cb161a91468', handleStr='')
ctx = None

    def testChannelOwnerCanAddownerWhenMember(userWoody, woodysPublicToybox, userBuzz, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
        channelAddowner(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)
    
>       chDeets = channelDetails(userBuzz.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_addowner.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testNonMemberCannotAddOwner __________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1008728267098, ownerMembers=[1013215365071], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1350575627137, token='efc9da1f537dd7b8683885e738c1906628a82f121231cab84c92de212ee6a952', handleStr='')
ctx = None

    def testNonMemberCannotAddOwner(woodysPublicToybox, userBuzz, ctx):
        with pytest.raises(AccessError):
>           channelAddowner(userBuzz.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_addowner.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:77: in channelAddowner
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [400]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
>           raise error.InputError()
E           httpTests.error.InputError: 400 Bad Request: None

httpTests/fakepi/util.py:93: InputError
_________________ testGlobalOwnerNonMemberCantAddownerPrivate __________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=170358984430, token='e819cedbc6d7c0ee8fdc09648308526c2abcecb50aa369acf50756e83bc50d10', handleStr='')
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=698574518112, ownerMembers=[159706169484], allMembers=[])
ctx = None

    def testGlobalOwnerNonMemberCantAddownerPrivate(userWoody, zergsPrivateLair, ctx):
        with pytest.raises(AccessError):
>           channelAddowner(userWoody.token, zergsPrivateLair.channelId, userWoody.uId, ctx)

httpTests/channelTests/test_channel_addowner.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:77: in channelAddowner
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [400]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
>           raise error.InputError()
E           httpTests.error.InputError: 400 Bad Request: None

httpTests/fakepi/util.py:93: InputError
__________________ testGlobalOwnerNonMemberCantAddownerPublic __________________

userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=623733820297, token='6dd2c195b3d7482b2879fa28597233bb6c547e34ba99e182e83f88749336aeb3', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=513577712174, ownerMembers=[454989987338], allMembers=[])
ctx = None

    def testGlobalOwnerNonMemberCantAddownerPublic(userBuzz, woodysPublicToybox, ctx):
        with pytest.raises(AccessError):
>           channelAddowner(userBuzz.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_addowner.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:77: in channelAddowner
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [400]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
>           raise error.InputError()
E           httpTests.error.InputError: 400 Bad Request: None

httpTests/fakepi/util.py:93: InputError
_____________________________ testMemberSuccessful _____________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=502027348058, ownerMembers=[97328648791], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=97328648791, token='5935eff4d55c88d657c2fb645307e46291eb9b77733eef56014415f3d94a8768', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1110639160835, token='8f3d05d2c472f24ffa7d2e62ffa3f3c3883344a334a5a0216874cf25b42b3721', handleStr='')
ctx = None

    def testMemberSuccessful(woodysPublicToybox, userWoody, userBuzz, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
>       chDeets_1 = channelDetails(userWoody.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_details.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testNonMemberNotSuccessful __________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=640543414431, ownerMembers=[1540143222761], allMembers=[])
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1618293506965, token='46df9e38a2c8b9baca6b0180e19a1885ebd077604cff254e85b5e1ad056f01ed', handleStr='')
ctx = None

    def testNonMemberNotSuccessful(woodysPublicToybox, userZerg, ctx):
        with pytest.raises(AccessError):
>           channelDetails(userZerg.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_details.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testInvalidChannelId _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1355311098352, token='a604ba40d9a1a81ad9f2fc2eaa9026ea456c0db1588dcf3705d472920d381863', handleStr='')
ctx = None

    def testInvalidChannelId(userWoody, ctx):
        with pytest.raises(InputError):
>           channelDetails(userWoody.token, -1, ctx)

httpTests/channelTests/test_channel_details.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=300241616214, token='c8f3f5c37d276ab171f6ad79954ef62ce87871e22a9ec631a6a5796a42436cab', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=663414982840, ownerMembers=[300241616214], allMembers=[])
ctx = None

    def testInvalidToken(userWoody, woodysPublicToybox, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           channelDetails(userWoody.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_details.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testDuplicateInvite ______________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=142479850719, ownerMembers=[805991406945], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=805991406945, token='720f02f5ba0acc2502740d621b74d1344d13ddac9ad468a2e9987079f3af8786', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=655584425388, token='50f40d538b479202b7a92ed7f9229b3836cda27877a7be9c4c3d54ad2cbf61d6', handleStr='')
ctx = None

    def testDuplicateInvite(woodysPublicToybox, userWoody, userBuzz, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_invite.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testInviteGlobalOwner _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=120758928070, token='72a4e0ac9b52b048e8fd37122d958d5518c47253ecf91f2791a43adf25408d01', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1106765678091, token='a272b83059979450c7c8a0d2813e9534a4b704ebda4b3c2abe7a1d6f5ad11f47', handleStr='')
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=135755703557, ownerMembers=[1106765678091], allMembers=[])
ctx = None

    def testInviteGlobalOwner(userWoody, userZerg, zergsPrivateLair, ctx):
>       channelInvite(userZerg.token, zergsPrivateLair.channelId, userWoody.uId, ctx)

httpTests/channelTests/test_channel_invite.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testInviteGlobalMember ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=315305716590, token='15ab1c2fe6f595904510295f2fe838904f2c719e6903ee412949810c90d9f5d8', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=981737750613, token='17ac02d0eee0254f7c268841ba28b907a0a32532ff48ccd47724b90cac01b739', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1235571928122, ownerMembers=[315305716590], allMembers=[])
ctx = None

    def testInviteGlobalMember(userWoody, userBuzz, woodysPublicToybox, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_invite.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testInvitationFromNonChannelMember ______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1294345609802, token='28086dba302c9d7e5c71580fee4275d4370d7a5f0a94dbcd63d20d9ec96a431d', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=581524693482, token='70e994060b56596f8a8104649e10cdafcbc6da6c61386a8f3010b7b54fee12ea', handleStr='')
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=614640227497, ownerMembers=[952013705093], allMembers=[])
ctx = None

    def testInvitationFromNonChannelMember(userWoody, userBuzz, zergsPrivateLair, ctx):
        with pytest.raises(AccessError):
>           channelInvite(userWoody.token, zergsPrivateLair.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_invite.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testChannelIdInvalid _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=614060468376, token='a10b422e17fbfaa6a416f38b83cb0c49ab96c15dead96509aad06a37c981073b', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=79585591721, token='c0108c39c235d8bd4e86758e45bb28258c422b3492b5d49065f820f8cc554c9c', handleStr='')
ctx = None

    def testChannelIdInvalid(userWoody, userBuzz, ctx):
        with pytest.raises(InputError):
>           channelInvite(userWoody.token, -1, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_invite.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________________ testUIdInvalid ________________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1127171825516, token='29756a82eb39a8b93be2171849e20d8aaa6308d42d719443366748ecf74ed6f5', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=292117490697, ownerMembers=[1127171825516], allMembers=[])
ctx = None

    def testUIdInvalid(userWoody, woodysPublicToybox, ctx):
        with pytest.raises(InputError):
>           channelInvite(userWoody.token, woodysPublicToybox.channelId, -1, ctx)

httpTests/channelTests/test_channel_invite.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testInvalidatedToken _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=995617445375, token='89c7658a788e6c85c1d63fd27be21a316f34bd088a1a212f33fe2a7ef5a5b14f', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1302158525237, ownerMembers=[995617445375], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=81452733542, token='38a018ec895a7c768f25bc9e688c7d59e3e4bbf2a7ee30bb494066a1d71abba8', handleStr='')
ctx = None

    def testInvalidatedToken(userWoody, woodysPublicToybox, userBuzz, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_invite.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________ testGlobalOwnerJoinChannelPublic _______________________

userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=497388568034, token='f5192a178d6a348a3d356b255399d96a16818785cb267e655604483ad20edbba', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=294305784327, ownerMembers=[743460264609], allMembers=[])
ctx = None

    def testGlobalOwnerJoinChannelPublic(userBuzz, woodysPublicToybox, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
>       chDeets = channelDetails(userBuzz.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_join.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testGlobalOwnerJoinChannelPrivate _______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1340981061666, token='21bc58eb7c1218041b1dce57d8756b91b3ca8b41efa87a2e246d97c3db45d1b0', handleStr='')
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=251101833268, ownerMembers=[206471290047], allMembers=[])
ctx = None

    def testGlobalOwnerJoinChannelPrivate(userWoody, zergsPrivateLair, ctx):
        channelJoin(userWoody.token, zergsPrivateLair.channelId, ctx)
    
>       chDeets = channelDetails(userWoody.token, zergsPrivateLair.channelId, ctx)

httpTests/channelTests/test_channel_join.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testGlobalMemberJoinPublic __________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=597347840748, ownerMembers=[1464000169792], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1233521234938, token='bf59fabb992a7cbc4636ab982f03a1e52b72be135d98c397fd304adbf28b3206', handleStr='')
ctx = None

    def testGlobalMemberJoinPublic(woodysPublicToybox, userBuzz, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
>       chDeets = channelDetails(userBuzz.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_join.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testMemberLeaveChannelSuccessfully ______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1648481288540, token='4cab47c547dca39cc1cf7b10afe3513b8c33f49429f2662b3be7c7c4278d1be8', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1585026099590, ownerMembers=[1648481288540], allMembers=[])
ctx = None

    def testMemberLeaveChannelSuccessfully(userWoody, woodysPublicToybox, ctx):
>       channelLeave(userWoody.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_leave.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:51: in channelLeave
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testLeaveChannelWhenNotMember _________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=965092452483, ownerMembers=[245744087879], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1304059898538, token='31705c46d273afa61efb57ebd5be48b29c2c9de016b690884397f4b211186da5', handleStr='')
ctx = None

    def testLeaveChannelWhenNotMember(woodysPublicToybox, userBuzz, ctx):
        with pytest.raises(AccessError):
>           channelLeave(userBuzz.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_leave.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:51: in channelLeave
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testInvalidChannelId _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1360951337183, token='0f6c0c16529e31f4f08cb1a65144b98c73936a1410dbdf9bb8da4982f4a51320', handleStr='')
ctx = None

    def testInvalidChannelId(userWoody, ctx):
        with pytest.raises(InputError):
>           channelLeave(userWoody.token, -1, ctx)

httpTests/channelTests/test_channel_leave.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:51: in channelLeave
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1538565141967, token='7a56a1bd1f2fc5d8777689988ad62e317cced2a70a72b8fedfbfede798c295d2', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1384426137768, ownerMembers=[1538565141967], allMembers=[])
ctx = None

    def testInvalidToken(userWoody, woodysPublicToybox, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           channelLeave(userWoody.token, woodysPublicToybox.channelId, ctx)

httpTests/channelTests/test_channel_leave.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:51: in channelLeave
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testMessageTimestamp _____________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=885360707067, ownerMembers=[1342130692521], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1342130692521, token='52e75fbffec3ebc92cdac1b77ddbb65c58092e81a6257d1a39745fe149dbfe35', handleStr='')
ctx = None

    def testMessageTimestamp(woodysPublicToybox, userWoody, ctx):
        expectedTime = utcNow()
>       messageSend(userWoody.token, woodysPublicToybox.channelId, 'you are a toy', ctx)

httpTests/channelTests/test_channel_messages.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testUnderFiftyMessagesSent __________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=981192903477, ownerMembers=[190890602170], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=190890602170, token='9dd017556676928c60bbdf05d3cb8ace20fce9f6c2520006dc4d0be9a0fd10f3', handleStr='')
ctx = None

    def testUnderFiftyMessagesSent(woodysPublicToybox, userWoody, ctx):
>       messageIds = [
            messageSend(userWoody.token, woodysPublicToybox.channelId, 'you are a toy', ctx)['messageId'] for x in
            range(10)
        ]

httpTests/channelTests/test_channel_messages.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/channelTests/test_channel_messages.py:24: in <listcomp>
    messageSend(userWoody.token, woodysPublicToybox.channelId, 'you are a toy', ctx)['messageId'] for x in
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testOverFiftyMessagesSent ___________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=183687516430, ownerMembers=[312512490118], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=312512490118, token='3bd827ff11021798fc19218edcff1b4b64c3c315e757fff2f9f3183988e2d4b0', handleStr='')
ctx = None

    def testOverFiftyMessagesSent(woodysPublicToybox, userWoody, ctx):
>       messageIds = [
            messageSend(userWoody.token, woodysPublicToybox.channelId, 'you are a toy', ctx)['messageId'] for x in
            range(51)
        ]

httpTests/channelTests/test_channel_messages.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/channelTests/test_channel_messages.py:37: in <listcomp>
    messageSend(userWoody.token, woodysPublicToybox.channelId, 'you are a toy', ctx)['messageId'] for x in
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testRemovalByEditReflected __________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1401850598870, ownerMembers=[1262265775418], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1262265775418, token='3d94673fb42a15b0647b127ac327bb291a5423efc0929986c88f78265073ca00', handleStr='')
ctx = None

    def testRemovalByEditReflected(woodysPublicToybox, userWoody, ctx):
>       msg = messageSend(userWoody.token, woodysPublicToybox.channelId, 'you are a toy maybe?', ctx)['messageId']

httpTests/channelTests/test_channel_messages.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testRemovalByDeletionReflected ________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=494866687881, ownerMembers=[327944481935], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=327944481935, token='56938d379e559dd4768f504b70317efc0468e999eeb6a6329a36be4d8976357b', handleStr='')
ctx = None

    def testRemovalByDeletionReflected(woodysPublicToybox, userWoody, ctx):
>       msg = messageSend(userWoody.token, woodysPublicToybox.channelId, 'you are a toy maybe?', ctx)['messageId']

httpTests/channelTests/test_channel_messages.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________ testInputErrorWhenStartGreaterThanMessageNum _________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1426484392908, ownerMembers=[115750261400], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=115750261400, token='0b9e2bfeb890cfcc43b5d16065164fe743b72b8f3e975386abc98970be8aeb19', handleStr='')
ctx = None

    def testInputErrorWhenStartGreaterThanMessageNum(woodysPublicToybox, userWoody, ctx):
        with pytest.raises(InputError):
>           channelMessages(userWoody.token, woodysPublicToybox.channelId, 21389429, ctx)

httpTests/channelTests/test_channel_messages.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testAccessErrorWhenUserIsNonMember ______________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=558821657082, ownerMembers=[515015526228], allMembers=[])
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=693487998368, token='6c86eeac21f9f78f07382642e65a3d49032bba6356d8b9f940467e275af5a81f', handleStr='')
ctx = None

    def testAccessErrorWhenUserIsNonMember(woodysPublicToybox, userZerg, ctx):
        with pytest.raises(AccessError):
>           channelMessages(userZerg.token, woodysPublicToybox.channelId, 0, ctx)

httpTests/channelTests/test_channel_messages.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testInputErrorWhenChannelIdInvalid ______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1067359078178, token='9b0df8e3a963e5f1eb320e3c5652b4acfa73e9705f2bf8605574ccdee6bc15c2', handleStr='')
ctx = None

    def testInputErrorWhenChannelIdInvalid(userWoody, ctx):
        with pytest.raises(InputError):
>           channelMessages(userWoody.token, -1, 0, ctx)

httpTests/channelTests/test_channel_messages.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________ testAccessErrorWhenInvalidTokenGiven _____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1011081344180, token='470be465bad78c80e6265257eb4580d74a182427e9296c2a8f7d64bf6f306ea1', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=228165524266, ownerMembers=[1011081344180], allMembers=[])
ctx = None

    def testAccessErrorWhenInvalidTokenGiven(userWoody, woodysPublicToybox, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           channelMessages(userWoody.token, woodysPublicToybox.channelId, 0, ctx)

httpTests/channelTests/test_channel_messages.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testOwnerCanRemoveOwner ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=834416524143, token='000b2757114cf0dc885d101bac0c725221e8c99dde5a14fab6ac472a7abd9557', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=920704354730, ownerMembers=[834416524143], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=745690217914, token='b371556a14fbd163dc5b53a1a3a29b0302b7832ad7c81ed223d16e9b85912789', handleStr='')
ctx = None

    def testOwnerCanRemoveOwner(userWoody, woodysPublicToybox, userBuzz, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_removeowner.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testGlobalOwnerMmberCanRemoveOwner ______________________

userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1213267600712, token='e58de89ee25aa991df01b87cf1b642299bdef3be27bddc4016d789182473504a', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=489634304723, token='d47a1456470e70edbe29a745c55c4625877c3111222d7ab2a584bf0597770852', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1271333146524, ownerMembers=[489634304723], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=672371026348, token='3fb539062856e310fbb1ce7b1c098cfbcfb36cf19e747aa162b5cdb8da49bd7c', handleStr='')
ctx = None

    def testGlobalOwnerMmberCanRemoveOwner(userZerg, userWoody, woodysPublicToybox, userBuzz, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_removeowner.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________ testGlobalOwnerNonmemberCannotRemoveOwner ___________________

userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1652296718020, token='9fc665a7cbede19fe93af443df6ee4debcb97ae2353b569f1cc7a287a5de7d69', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=380806282500, token='2cc6efe351bd294e5ce8bae2d94239b1a46131d57ef075af3a2e03554b5468e8', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=255775711178, ownerMembers=[380806282500], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1072320583440, token='e30b3e3a69aac47860475a9a710276d2929e499f64fb543e5f2cc5546b5d552f', handleStr='')
ctx = None

    def testGlobalOwnerNonmemberCannotRemoveOwner(userZerg, userWoody, woodysPublicToybox, userBuzz, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channelTests/test_channel_removeowner.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testNonmemberCannotRemoveOwner ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=500199948021, token='f397ed4413fabff410a04610b8d9d7dcaf7b648433b7ee64daa9ae156cb06fb5', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=402802199593, ownerMembers=[500199948021], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=626117598606, token='5ddfa18e857ffc7f3378fcac850b4579ddcbe0dbd08924b5aa48e7b93009e5e7', handleStr='')
ctx = None

    def testNonmemberCannotRemoveOwner(userWoody, woodysPublicToybox, userBuzz, ctx):
        with pytest.raises(AccessError):
>           channelRemoveowner(userBuzz.token, woodysPublicToybox.channelId, userWoody.uId, ctx)

httpTests/channelTests/test_channel_removeowner.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:90: in channelRemoveowner
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [400]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
>           raise error.InputError()
E           httpTests.error.InputError: 400 Bad Request: None

httpTests/fakepi/util.py:93: InputError
__________________________ testMmberCannotRemoveOwner __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1060410230077, token='25730ee3780d473693e660e6694d28dc3a43c6ca2073360dee2ef3e2d9e30d75', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=388694845357, ownerMembers=[1060410230077], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=48419735707, token='fcb6b765b1ed2edbe5311835f8d3a9e6290bc0e5c885251bb9250044550d2079', handleStr='')
ctx = None

    def testMmberCannotRemoveOwner(userWoody, woodysPublicToybox, userBuzz, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
        with pytest.raises(AccessError):
>           channelRemoveowner(userBuzz.token, woodysPublicToybox.channelId, userWoody.uId, ctx)

httpTests/channelTests/test_channel_removeowner.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:90: in channelRemoveowner
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [400]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
>           raise error.InputError()
E           httpTests.error.InputError: 400 Bad Request: None

httpTests/fakepi/util.py:93: InputError
______________________ testCreateChannel[True-andys room] ______________________

name = 'andys room', isPublic = True
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=780574812153, token='0806a60bc3c8ccafb229d84265f8346921b18bec2e1f600ab0a5bcc469c81253', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=646722588697, token='09f9b1a0aadc9393e4727e687f4572fdebb978ae12f9bb9e02e789afd6006a0b', handleStr='')
ctx = None

    @pytest.mark.parametrize('name', ['andys room'])
    @pytest.mark.parametrize('isPublic', [True, False])
    def testCreateChannel(name, isPublic, userZerg, userWoody, ctx):
        chId = channelsCreate(userZerg.token, name, isPublic, ctx)['channelId']
>       deets = channelDetails(userZerg.token, chId, ctx)

httpTests/channels_tests/test_channels_create.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________ testCreateChannel[False-andys room] ______________________

name = 'andys room', isPublic = False
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1379312742839, token='785a42dc2f45aaa6efff4e78b9e508771ac8074ec6803e7fb3be4814af474cb5', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1066030426947, token='96ba3615c5e79647a2ea4a1261ba846a6477c5ef9eb48a5c3412f327a55391a1', handleStr='')
ctx = None

    @pytest.mark.parametrize('name', ['andys room'])
    @pytest.mark.parametrize('isPublic', [True, False])
    def testCreateChannel(name, isPublic, userZerg, userWoody, ctx):
        chId = channelsCreate(userZerg.token, name, isPublic, ctx)['channelId']
>       deets = channelDetails(userZerg.token, chId, ctx)

httpTests/channels_tests/test_channels_create.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:25: in channelDetails
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testListAfterLeaveChannel ___________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1291694234143, ownerMembers=[554210116281], allMembers=[])
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=554210116281, token='e9d82a984ae3ea253f746d5d0af098a54309537394b1928b9c2069780452b963', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1411417417228, token='0cde20386eafcf15a0ae2242b29139dac4312fe98726a016d9bcfa0679433703', handleStr='')
ctx = None

    def testListAfterLeaveChannel(woodysPublicToybox, userWoody, userBuzz, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/channels_tests/test_channels_list.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testDmNameCreationMultiple __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=907449995993, token='1a39221944feb6aa998c2360239a8533af5531aa6ac89a352f18d53febd1b8b7', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=544865778346, token='756a20f7a62ccea05afbf7f1e0fa2b1ac295bf1dad58cc1a0ebe343fdda7555d', handleStr='')
ctx = None

    def testDmNameCreationMultiple(userWoody, userBuzz, ctx):
        theDm = dmCreate(userWoody.token, [userBuzz.uId], ctx)
        dmDeets = dmDetails(userWoody.token, theDm['dmId'], ctx)
    
>       assert dmDeets['name'] == ', '.join(sorted([userWoody.handleStr, userBuzz.handleStr]))
E       assert "'buzzlightyear, sheriffwoody'" == ', '
E         - , 
E         + 'buzzlightyear, sheriffwoody'

httpTests/dmTests/test_dm_create.py:36: AssertionError
_____________________________ testMemberSuccessful _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=311877385403, token='150bd48bf82490aaec42cafc1bc9be777194590fb3763753f3e7078aa13d76a7', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1361382630191, token='bfc27379a30978b5badd53d89ad68705ddb4b07f3455fc426d761a2102254bd2', handleStr='')
woodyAndBuzzDm = DM(owner=311877385403, members=[1361382630191], name="'buzzlightyear, sheriffwoody'", dmId=613292187238)
ctx = None

    def testMemberSuccessful(userWoody, userBuzz, woodyAndBuzzDm, ctx):
        dmDeets = dmDetails(userBuzz.token, woodyAndBuzzDm.dmId, ctx)
    
        assert dmDeets['name'] == woodyAndBuzzDm.name
    
        sortedMembers = sorted(dmDeets['members'], key=lambda m: m['handleStr'])
        sortedUsers = sorted([userBuzz, userWoody], key=lambda m: m.handleStr)
    
        for detail, usr in zip(sortedMembers, sortedUsers):
            assert detail['uId'] == usr.uId
            assert detail['email'] == usr.email
            assert detail['nameFirst'] == usr.nameFirst
            assert detail['nameLast'] == usr.nameLast
>           assert detail['handleStr'] == usr.handleStr
E           AssertionError: assert 'buzzlightyear' == ''
E             + buzzlightyear

httpTests/dmTests/test_dm_details.py:27: AssertionError
__________________________ testRemovalByEditReflected __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1052559611320, token='c92f90404e776ef421c0150e8c6b636c2773ee7eb0155368075331610d79f9af', handleStr='')
woodyAndBuzzDm = DM(owner=1052559611320, members=[499344439461], name="'buzzlightyear, sheriffwoody'", dmId=491392350823)
ctx = None

    def testRemovalByEditReflected(userWoody, woodyAndBuzzDm, ctx):
        msg = messageSenddm(userWoody.token, woodyAndBuzzDm.dmId, 'you are a toy maybe?', ctx)['messageId']
    
        dmMsgs = dmMessages(userWoody.token, woodyAndBuzzDm.dmId, 0, ctx)
        assert dmMsgs['start'] == 0
        assert dmMsgs['end'] == -1
        assert msg in [m['messageId'] for m in dmMsgs['messages']]
    
>       messageEdit(userWoody.token, msg, '', ctx)

httpTests/dmTests/test_dm_messages.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:37: in messageEdit
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testRemovalByDeletionReflected ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1222030342074, token='3ad89f00367f476a723a78af28a3dc8437ca4d6a8de5fb8e32d7dfc2a6926fb6', handleStr='')
woodyAndBuzzDm = DM(owner=1222030342074, members=[1931393261], name="'buzzlightyear, sheriffwoody'", dmId=682704764499)
ctx = None

    def testRemovalByDeletionReflected(userWoody, woodyAndBuzzDm, ctx):
        msg = messageSenddm(userWoody.token, woodyAndBuzzDm.dmId, 'you are a toy maybe?', ctx)['messageId']
    
        chMsgs = dmMessages(userWoody.token, woodyAndBuzzDm.dmId, 0, ctx)
        assert chMsgs['start'] == 0
        assert chMsgs['end'] == -1
        assert msg in [m['messageId'] for m in chMsgs['messages']]
    
>       messageRemove(userWoody.token, msg, ctx)

httpTests/dmTests/test_dm_messages.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:24: in messageRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________ testOriginalPosterCanEditMessageChannel ____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=705460362959, token='c746fdf60db8b41f05ebb98481aad3689604a7f619181df89355b3b3ba855c37', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=206519631517, ownerMembers=[705460362959], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c59b80>
ctx = None

    def testOriginalPosterCanEditMessageChannel(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_edit.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testOriginalPosterCanEditMessageDm ______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=578033072134, token='ca186f36063219c336ff27b3c445f6a39ac99d3711853352ae70b7a9ee4a6666', handleStr='')
woodyAndBuzzDm = DM(owner=578033072134, members=[233743739054], name="'buzzlightyear, sheriffwoody'", dmId=582653036609)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c631f0>
ctx = None

    def testOriginalPosterCanEditMessageDm(userWoody, woodyAndBuzzDm, messageFactory, ctx):
        aMsg = messageFactory(userWoody, woodyAndBuzzDm)
    
>       messageEdit(userWoody.token, aMsg.messageId, 'hi', ctx)

httpTests/messageTests/test_message_edit.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:37: in messageEdit
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________ testGlobalOwnerCantEditMembersMessageDm ____________________

userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=461351424244, token='304d0fd4abef894d9f898cf8b979c3a322fbd3a9f5cfb1296e0dbd235ce302ae', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=831911736774, token='5c3e99156775131008c9c9623bee7c081f78c998be3522b645eacfeb92366477', handleStr='')
woodyAndBuzzDm = DM(owner=831911736774, members=[461351424244], name="'buzzlightyear, sheriffwoody'", dmId=241456547099)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d27d30>
ctx = None

    def testGlobalOwnerCantEditMembersMessageDm(userBuzz, userWoody, woodyAndBuzzDm, messageFactory, ctx):
        woodysMsg = messageFactory(userWoody, woodyAndBuzzDm)
        with pytest.raises(AccessError):
>           messageEdit(userBuzz.token, woodysMsg.messageId, 'hi', ctx)

httpTests/messageTests/test_message_edit.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:37: in messageEdit
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testEmptyEditDeletesMessage __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=961596023583, token='16c3a4faa9a9aafead85dfa7afac7cffff16727c9ed484f3af7c1521dd02ea5b', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1282468533920, ownerMembers=[961596023583], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c638b0>
ctx = None

    def testEmptyEditDeletesMessage(userWoody, woodysPublicToybox, messageFactory, ctx):
>       woodysMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_edit.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testInvalidMessageLength ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1515271448845, token='17f8a22d994dc8bd2fbae8ddf7d3da14e2476bb74641e9fefc855395e2b1423b', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=132142509396, ownerMembers=[1515271448845], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c14820>
ctx = None

    def testInvalidMessageLength(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox, 'hi')

httpTests/messageTests/test_message_edit.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testCannotEditDeletedMessage _________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1624294810505, token='3db5c7965153fbe360f6bd1b7c98ea0c366eb022b738352a67dc7c02e3d51d84', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=167484027957, ownerMembers=[1624294810505], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c63280>
ctx = None

    def testCannotEditDeletedMessage(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox, 'hi')

httpTests/messageTests/test_message_edit.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testNonownerNonposterCantEdit _________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=748626179160, token='1dda234d09e2c6206c855c6caea39f0e414125c7dde52a569105892495bd2f1e', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=185482235144, ownerMembers=[748626179160], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1510504593772, token='cf359f57b5d6d709a6df2ddfda7fe6979fe13d1cc88775be8229b3a76c47fefc', handleStr='')
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c005e0>
ctx = None

    def testNonownerNonposterCantEdit(userWoody, woodysPublicToybox, userBuzz, messageFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
>       woodysMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_edit.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=261159128528, token='2fa4672b3d3e8206c9b183b2ef26a0e2b6dfde009ac2e8904b3ecba9398a6417', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=879977796484, ownerMembers=[261159128528], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47cc2310>
ctx = None

    def testInvalidToken(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_edit.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testMessageIdsUnique _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=32117952353, token='2352ffd85126cf0b0aa7790203ee71b56f744bbb4d3a1e0cd7160abf1a0ec9a7', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1010067868202, token='bf5487a321475681cc90c1d5187cbbe0ed4857b56f8b152d0b5265ecef93c6b0', handleStr='')
woodyAndBuzzDm = DM(owner=32117952353, members=[1076954641216], name="'buzzlightyear, sheriffwoody'", dmId=1539017335809)
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=1367269244637, ownerMembers=[1010067868202], allMembers=[])
ctx = None

    @pytest.mark.marks(0.5)
    def testMessageIdsUnique(userWoody, userZerg, woodyAndBuzzDm, zergsPrivateLair, ctx):
>       msg1 = messageSend(userZerg.token, zergsPrivateLair.channelId, 'hi', ctx)

httpTests/messageTests/test_message_meta.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testMessageIdsUniqueIter3 ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=591178802063, token='3ec9cc07fd34a2efc7a0898e2dc2546087ea08c1468343021b2b10d67e5d127d', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=594014233559, token='293c5cc3db153dac2e2f84270d704740d5943e4eb6f7e35ad24099e8fb7310ff', handleStr='')
woodyAndBuzzDm = DM(owner=591178802063, members=[1543103140047], name="'buzzlightyear, sheriffwoody'", dmId=340212444281)
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=436883228225, ownerMembers=[594014233559], allMembers=[])
ctx = None

    @pytest.mark.marks(0.5)
    @iteration3
    def testMessageIdsUniqueIter3(userWoody, userZerg, woodyAndBuzzDm, zergsPrivateLair, ctx):
>       msg1 = messageSend(userZerg.token, zergsPrivateLair.channelId, 'hi', ctx)

httpTests/messageTests/test_message_meta.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________ testSuccessfulPinChannelOwnerInChannel ____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=738459523206, token='0baf2b0b716750fe000d59aa60ed8c643c5f63687d82d56b24b0cee3b78532e9', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1494010733071, ownerMembers=[738459523206], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47ce1c10>
ctx = None

    @iteration3
    def testSuccessfulPinChannelOwnerInChannel(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_pin.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________ testSuccessfulPinGlobalOwnerInChannel _____________________

userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1530487243304, token='8ca0f162cd627a6d7202693132e3591be5b806550037cc61e67101c3ca52450b', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1399857904603, token='b15a26e162b98272b5cf86ca18f92393b8361468748e707f116184a080db8fca', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=871647588634, ownerMembers=[1399857904603], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d27ee0>
ctx = None

    @iteration3
    def testSuccessfulPinGlobalOwnerInChannel(userBuzz, userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_pin.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________________ testCannotPinTwice ______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=542877782987, token='fdf9fca40f2dd8cf509ed36542b074707dacd7d6fdf05d34a20c9bf20bb803c3', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=544820981703, ownerMembers=[542877782987], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c639d0>
ctx = None

    @iteration3
    def testCannotPinTwice(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_pin.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testChannelMemberCantPin ___________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1167373019689, ownerMembers=[883142187388], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1102258429874, token='8879b125d088e4143796f224f6a228ac777c3d5d2ed5b35dbfcd37a9de2577f3', handleStr='')
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c59d30>
ctx = None

    @iteration3
    def testChannelMemberCantPin(woodysPublicToybox, userBuzz, messageFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
>       aMsg = messageFactory(userBuzz, woodysPublicToybox)

httpTests/messageTests/test_message_pin.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testNonmemberCantPin _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1655206688335, token='0246aa07961eb756b5e7a1b39948ea937a64f8df4110742ceddb284d53058cf1', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1586783846309, token='694f37295fa25d4117b5d43f538243d11178ad09eee343b68243bad0ad075838', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=275569843861, ownerMembers=[1655206688335], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d8a5e0>
ctx = None

    @iteration3
    def testNonmemberCantPin(userWoody, userZerg, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_pin.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=617342881417, token='4016d2b865846f83f73d8b06d380489faba73c2e6185235db1cc9556c3021b3d', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=940192918904, ownerMembers=[617342881417], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47cc2160>
ctx = None

    @iteration3
    def testInvalidToken(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_pin.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testSuccessfulReactInChannel _________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1484988465604, token='b63e18d069a3990fef3457c11a34b0ebf565438a607dda6bd2b2a7fd9bc1095b', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1209619116360, token='0fc5a2536c3e64930381aa7c9c6a362dd54609526a2c38d0cc64eee6f90a88e2', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=412207186462, ownerMembers=[1484988465604], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d8ae50>
ctx = None

    @iteration3
    def testSuccessfulReactInChannel(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_react.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________________ testInvalidReactId ______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=656865714342, token='420e48028217bc93893c8d30bb7ee5a979855e6b9169a252eb5d768f5fc222ea', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=298539968513, ownerMembers=[656865714342], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d77e50>
ctx = None

    @iteration3
    def testInvalidReactId(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_react.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________________ testCantReactTwice ______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=721470251192, token='fd174771158b6f4212e0e9dc067b1e53cb49d4ea51b9d7dd3258fcacab162b33', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1529517394077, ownerMembers=[721470251192], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d32670>
ctx = None

    @iteration3
    def testCantReactTwice(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_react.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testNonmemberCannotReact ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1181084480422, token='2dac06da6762fc9f69a8022296c052c7cb90f19d63fce2749a557f0fab2a9e10', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=171932434225, token='f0a5afadbef7307482146d99a258736be68aa1469769c68453a7f1df70f81e1d', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1483476724370, ownerMembers=[1181084480422], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c65af0>
ctx = None

    @iteration3
    def testNonmemberCannotReact(userWoody, userZerg, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_react.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=682877966149, token='29df80b606802e24fbf97b5da08e8769cdc81b5ab878bd5083997f39724e76a6', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=323977308064, ownerMembers=[682877966149], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d8a5e0>
ctx = None

    @iteration3
    def testInvalidToken(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_react.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testOriginalPosterCanRemoveMessage ______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=774990301770, token='adaf458d3de800d7ed4293f88fc65b8ac9a3a144d068bf0b98846632d129c335', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=508077726382, ownerMembers=[774990301770], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47cea3a0>
ctx = None

    def testOriginalPosterCanRemoveMessage(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_remove.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________ testGlobalOwnerCantRemoveMembersMessageDm ___________________

userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=285058202637, token='d3a8cc2d70ea0fbffb28a69afad2ea521c430feca78a251afd1258879d9a5e94', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=52668401232, token='a9b496c67c94d369fb4ddc2cc96126455653b70c226ba9c5ab431e179a129ef7', handleStr='')
woodyAndBuzzDm = DM(owner=52668401232, members=[285058202637], name="'buzzlightyear, sheriffwoody'", dmId=745746264988)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c001f0>
ctx = None

    def testGlobalOwnerCantRemoveMembersMessageDm(userBuzz, userWoody, woodyAndBuzzDm, messageFactory, ctx):
        woodysMsg = messageFactory(userWoody, woodyAndBuzzDm)
        with pytest.raises(AccessError):
>           messageRemove(userBuzz.token, woodysMsg.messageId, ctx)

httpTests/messageTests/test_message_remove.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:24: in messageRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testCannotRemoveDeletedMessage ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=826848741969, token='66b80088e6f658ba7e3996567541740133cde047a5742e4eaac11229867b6ffa', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=664110419232, ownerMembers=[826848741969], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bdbc10>
ctx = None

    def testCannotRemoveDeletedMessage(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox, 'hi')

httpTests/messageTests/test_message_remove.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________ testNonownerNonposterCantRemoveMessage ____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=907377209371, token='d57ffec09b122d9687dcaaa50d3ad27ae351dae6d415b77876f1ec2ade1d8c1f', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=811810580249, ownerMembers=[907377209371], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=676861615925, token='fd3844f89ab9f7565b842f0b9356bb4a1b7d1186a0151c1ff61c6817d8e234f2', handleStr='')
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c14ee0>
ctx = None

    def testNonownerNonposterCantRemoveMessage(userWoody, woodysPublicToybox, userBuzz, messageFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
>       woodysMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_remove.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1278861092191, token='fcf9d5ec9e23e7d8e814eb9134f5b2771e3893bbf7448990dca48a04e59f5055', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=949935629096, ownerMembers=[1278861092191], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47cea550>
ctx = None

    def testInvalidToken(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_remove.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testValidMessage _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=712781825962, token='24a129065f2cb5be13032d3ee59fbcab7c646d149adabd910806afc32f93a2c0', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=870093526717, ownerMembers=[712781825962], allMembers=[])
ctx = None

    def testValidMessage(userWoody, woodysPublicToybox, ctx):
        msgText = 'hello, world'
>       msg = messageSend(userWoody.token, woodysPublicToybox.channelId, msgText, ctx)

httpTests/messageTests/test_message_send.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________________ testNonmemberPost _______________________________

woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=852003459223, ownerMembers=[1117499820124], allMembers=[])
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1566416072665, token='94446568bc8bfbfb9bfa5d5680e4270337ef9fa2fb151dbafaa53e9ea12871ff', handleStr='')
ctx = None

    def testNonmemberPost(woodysPublicToybox, userBuzz, ctx):
        with pytest.raises(AccessError):
>           messageSend(userBuzz.token, woodysPublicToybox.channelId, 'hi', ctx)

httpTests/messageTests/test_message_send.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________________ testInvalidChannel ______________________________

userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=227343575516, token='36d9823f386d1302b823cd225fa89fbd8b169c59d84e18565fc4f37d742d4034', handleStr='')
ctx = None

    def testInvalidChannel(userBuzz, ctx):
        with pytest.raises(InputError):
>           messageSend(userBuzz.token, -1, 'Hello world', ctx)

httpTests/messageTests/test_message_send.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testInvalidMessage[] _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=519237200220, token='2b57ab876aefc0f3dcd43912ded7b05fe7b9a6cf4a3b1b3fb82d9a9aadcd5e7f', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=528420288013, ownerMembers=[519237200220], allMembers=[])
message = '', ctx = None

    @pytest.mark.parametrize('message', ['', 'm' * 1001])
    def testInvalidMessage(userWoody, woodysPublicToybox, message, ctx):
        with pytest.raises(InputError):
>           messageSend(userWoody.token, woodysPublicToybox.channelId, message, ctx)

httpTests/messageTests/test_message_send.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_ testInvalidMessage[mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm] _

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1139805376158, token='b3d12b91670eae8f009e60b7f89812f68ede347459fb1f6e26c0979cb758eb21', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1155427728319, ownerMembers=[1139805376158], allMembers=[])
message = 'mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm...mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm'
ctx = None

    @pytest.mark.parametrize('message', ['', 'm' * 1001])
    def testInvalidMessage(userWoody, woodysPublicToybox, message, ctx):
        with pytest.raises(InputError):
>           messageSend(userWoody.token, woodysPublicToybox.channelId, message, ctx)

httpTests/messageTests/test_message_send.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1219359344508, token='94e3c49b6fe73bd31c0bdfa9bf2ff0342193284e735087b48455afaeda9f8bc8', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=90944194212, ownerMembers=[1219359344508], allMembers=[])
ctx = None

    def testInvalidToken(userWoody, woodysPublicToybox, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           messageSend(userWoody.token, woodysPublicToybox.channelId, 'AccessError nooooooooo', ctx)

httpTests/messageTests/test_message_send.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testValidFutureMessage ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=299836662885, token='7cbe0d8dc0d2a63e7e397cef7c78135e8bc0c3f4cf405956630b9deca297a3bc', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=624763882226, ownerMembers=[299836662885], allMembers=[])
ctx = None

    @iteration3
    def testValidFutureMessage(userWoody, woodysPublicToybox, ctx):
        msgText = 'hello, world'
        tts = utcNow() + 2
        msg = messageSendlater(userWoody.token, woodysPublicToybox.channelId, msgText, tts, ctx)
    
        sleep(3)
    
>       chMsgs = channelMessages(userWoody.token, woodysPublicToybox.channelId, 0, ctx)

httpTests/messageTests/test_message_sendlater.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testReturnsImmediately ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=641397059279, token='0689d7fb20809914b9704f28955aabcdecc5126e23530e39058d2a5184282097', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1015864196425, ownerMembers=[641397059279], allMembers=[])
ctx = None

    @iteration3
    def testReturnsImmediately(userWoody, woodysPublicToybox, ctx):
        msgText = 'hello, world'
        timeReq = utcNow()
        tts = utcNow() + 2
        msg = messageSendlater(userWoody.token, woodysPublicToybox.channelId, msgText, tts, ctx)
    
        assert abs(timeReq - utcNow()) <= 1
    
>       chMsgs = channelMessages(userWoody.token, woodysPublicToybox.channelId, 0, ctx)

httpTests/messageTests/test_message_sendlater.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testInvalidReturnedIdUntilSent ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1514089223901, token='82c7052ab5e6cdfa7d6181a73a5c0f554d101740274dc0716123d419551c91d3', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=42932279622, ownerMembers=[1514089223901], allMembers=[])
ctx = None

    @iteration3
    def testInvalidReturnedIdUntilSent(userWoody, woodysPublicToybox, ctx):
        msgText = 'hello, world'
        tts = utcNow() + 2
        msg = messageSendlater(userWoody.token, woodysPublicToybox.channelId, msgText, tts, ctx)
    
        with pytest.raises(InputError):
>           messageRemove(userWoody.token, msg['messageId'], ctx)

httpTests/messageTests/test_message_sendlater.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:24: in messageRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1007127324065, token='3ec3bb12c43b40d45ac85e19dd87483e165654822e09ee34092117af8a8c8402', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=907003421591, ownerMembers=[1007127324065], allMembers=[])
ctx = None

    @iteration3
    def testInvalidToken(userWoody, woodysPublicToybox, ctx):
        authLogout(userWoody.token, ctx)
    
        with pytest.raises(AccessError):
>           messageSendlater(userWoody.token, woodysPublicToybox.channelId, 'hi', utcNow() + 2, ctx)

httpTests/messageTests/test_message_sendlater.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:128: in messageSendlater
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [400]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
>           raise error.InputError()
E           httpTests.error.InputError: 400 Bad Request: None

httpTests/fakepi/util.py:93: InputError
________________________ testInvalidReturnedIdUntilSent ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=80282653244, token='6b2b8340359c9ebd45a5a56a694c8956600df28899f057084b588f60660777e4', handleStr='')
woodyAndBuzzDm = DM(owner=80282653244, members=[1223801210643], name="'buzzlightyear, sheriffwoody'", dmId=554183260674)
ctx = None

    @iteration3
    def testInvalidReturnedIdUntilSent(userWoody, woodyAndBuzzDm, ctx):
        msgText = 'hello, world'
        tts = utcNow() + 2
        msg = messageSendlaterdm(userWoody.token, woodyAndBuzzDm.dmId, msgText, tts, ctx)
    
        with pytest.raises(InputError):
>           messageRemove(userWoody.token, msg['messageId'], ctx)

httpTests/messageTests/test_message_sendlaterdm.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:24: in messageRemove
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1308771414097, token='c5ea02b0962e52632171fca3bcb23cec5297c3f7ea7b39d7fae9373a8ebdca61', handleStr='')
woodyAndBuzzDm = DM(owner=1308771414097, members=[1550724551000], name="'buzzlightyear, sheriffwoody'", dmId=435278459291)
ctx = None

    @iteration3
    def testInvalidToken(userWoody, woodyAndBuzzDm, ctx):
        authLogout(userWoody.token, ctx)
    
        with pytest.raises(AccessError):
>           messageSendlaterdm(userWoody.token, woodyAndBuzzDm.dmId, 'hi', utcNow() + 2, ctx)

httpTests/messageTests/test_message_sendlaterdm.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/message.py:141: in messageSendlaterdm
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [400]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
>           raise error.InputError()
E           httpTests.error.InputError: 400 Bad Request: None

httpTests/fakepi/util.py:93: InputError
_________________________ testSuccessfulShareToChannel _________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=294196962333, token='9fab025d92e3177e76239805c789a1bfe4a93314d1bc4f2a6725e7046b986bfa', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=796614554105, ownerMembers=[294196962333], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47ce1ee0>
ctx = None

    @iteration3
    def testSuccessfulShareToChannel(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox, 'hi')

httpTests/messageTests/test_message_share.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testSuccessfulCrossShare[True] ________________________

toCh = True
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=574166265285, token='7f8310f6b94331520f5f7756ab937ac159d9741ccbfdf415586a2b605a820c61', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1071718077757, ownerMembers=[574166265285], allMembers=[])
woodyAndBuzzDm = DM(owner=574166265285, members=[1189296801058], name="'buzzlightyear, sheriffwoody'", dmId=381885410655)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bdb430>
ctx = None

    @iteration3
    @pytest.mark.parametrize('toCh', [True, False])
    def testSuccessfulCrossShare(toCh, userWoody, woodysPublicToybox, woodyAndBuzzDm, messageFactory, ctx):
        if toCh:
            aMsg = messageFactory(userWoody, woodyAndBuzzDm, 'hi')
            cross = messageShare(userWoody.token, aMsg.messageId, 'amazing', woodysPublicToybox.channelId, -1, ctx)
>           msgs = channelMessages(userWoody.token, woodysPublicToybox.channelId, 0, ctx)

httpTests/messageTests/test_message_share.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________ testSuccessfulCrossShare[False] ________________________

toCh = False
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=65119523032, token='5bf07e3d21aef4a6d441ec695260d05a5b5c2b3c0f71ce5ca95a26a9eac2cbff', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=563056492581, ownerMembers=[65119523032], allMembers=[])
woodyAndBuzzDm = DM(owner=65119523032, members=[927077969986], name="'buzzlightyear, sheriffwoody'", dmId=1092218106987)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d54700>
ctx = None

    @iteration3
    @pytest.mark.parametrize('toCh', [True, False])
    def testSuccessfulCrossShare(toCh, userWoody, woodysPublicToybox, woodyAndBuzzDm, messageFactory, ctx):
        if toCh:
            aMsg = messageFactory(userWoody, woodyAndBuzzDm, 'hi')
            cross = messageShare(userWoody.token, aMsg.messageId, 'amazing', woodysPublicToybox.channelId, -1, ctx)
            msgs = channelMessages(userWoody.token, woodysPublicToybox.channelId, 0, ctx)
        else:
>           aMsg = messageFactory(userWoody, woodysPublicToybox, 'hi')

httpTests/messageTests/test_message_share.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testCannotShareToUnjoinedDm __________________________

userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=805358051603, token='d8b678a5829c6d39a98aad27684433faf671d4cc4bb210955dd8eabbe72138be', handleStr='')
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=795234200890, ownerMembers=[805358051603], allMembers=[])
woodyAndBuzzDm = DM(owner=350677334531, members=[1405217693601], name="'buzzlightyear, sheriffwoody'", dmId=1224746524616)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d77700>
ctx = None

    @iteration3
    def testCannotShareToUnjoinedDm(userZerg, zergsPrivateLair, woodyAndBuzzDm, messageFactory, ctx):
>       aMsg = messageFactory(userZerg, zergsPrivateLair)

httpTests/messageTests/test_message_share.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________ testCannotShareToUnjoinedChannel _______________________

userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=1121214100315, token='f2de666a20519dad99ec93cbd5cfe106b8246c7b3becb0c622fe90ab76b203bf', handleStr='')
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=1046524837092, ownerMembers=[1121214100315], allMembers=[])
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=341294179262, ownerMembers=[465555174812], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c634c0>
ctx = None

    @iteration3
    def testCannotShareToUnjoinedChannel(userZerg, zergsPrivateLair, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userZerg, zergsPrivateLair)

httpTests/messageTests/test_message_share.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testCannotShareFromUnjoinedChannel ______________________

userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=694566099912, token='54ca9ff2bd3a40583347c095e3abe0de8170fc0748132727a2c6daafe6e4a6f0', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1510880367185, token='11dc42eebe951fc196d5c26c155cb5d98e592b638aedbb554680450362666fb4', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1383835992558, ownerMembers=[1510880367185], allMembers=[])
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=487306926751, ownerMembers=[694566099912], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c41b80>
ctx = None

    @iteration3
    def testCannotShareFromUnjoinedChannel(userZerg, userWoody, woodysPublicToybox, zergsPrivateLair, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_share.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testInvalidMessageLength ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=492014822620, token='1c17cbe7da6ee487454bfba470a9fc67f8b24ea84cb07c1906dbb50a6ef4e37f', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1355338178193, ownerMembers=[492014822620], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b8d1f0>
ctx = None

    @iteration3
    def testInvalidMessageLength(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_share.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testShareToInvalidDmId ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1483367463433, token='6ef17f2ef87214bbf4d81a73a0f48b5b304dd2406593edecc0207bd0a42850d2', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1429000865906, ownerMembers=[1483367463433], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c63820>
ctx = None

    @iteration3
    def testShareToInvalidDmId(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_share.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=889397684838, token='47036b644d5d61134ee4673cea2486d64173d292a95c4b9802b24a0118f410f6', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=319331679812, ownerMembers=[889397684838], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c65b80>
ctx = None

    @iteration3
    def testInvalidToken(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_share.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________ testSuccessfulUnpinChannelOwnerInChannel ___________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=523426611614, token='1ec799d1d897891d757aba6057d943271b70bfd521440e807e0bdddf71f924b3', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=140691587384, ownerMembers=[523426611614], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b8d700>
ctx = None

    @iteration3
    def testSuccessfulUnpinChannelOwnerInChannel(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unpin.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________ testSuccessfulUnpinGlobalOwnerInChannel ____________________

userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=510799271509, token='8e5599bbe49385fd29251ca6df25880df683206361698f89530fdabffdf1ca09', handleStr='')
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=558189381296, token='a5c41f198d5f2bcb2e1475db2f73b6a0fe27a42ac8eaf9fbb409a0b7afb9d5e3', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=668064151214, ownerMembers=[558189381296], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bac9d0>
ctx = None

    @iteration3
    def testSuccessfulUnpinGlobalOwnerInChannel(userBuzz, userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unpin.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testCannotUnpinTwice _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1367415422612, token='4cc70fddc5328387793c3bd4547fabde4e91cd784716206322ce323e6e5e5ad3', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=645264463829, ownerMembers=[1367415422612], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bbf430>
ctx = None

    @iteration3
    def testCannotUnpinTwice(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unpin.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testChannelMemberCantUnpin __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1640531069615, token='419ddf794e2e92159a49ebb529fe67ced307bfb8dd72eadcff473b281a76966a', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=854214278188, token='251b71419536c6c91068fa55bdfa52a77b6dfcc5dcdb95a0e97de01f4c6ca717', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1078929223204, ownerMembers=[1640531069615], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bacee0>
ctx = None

    @iteration3
    def testChannelMemberCantUnpin(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
>       aMsg = messageFactory(userBuzz, woodysPublicToybox)

httpTests/messageTests/test_message_unpin.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testNonmemberCantUnpin ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1642483905807, token='bac18a29187a70dc97ce858245161054c6031fae5039fa9f8fbd48a08cc20f6d', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=363744561063, token='adec548ee7ebfe013b1526e54665ca06df3a2e0c97e2a6d009c1ec3bcffbe306', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1482040953261, ownerMembers=[1642483905807], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b4d3a0>
ctx = None

    @iteration3
    def testNonmemberCantUnpin(userWoody, userZerg, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unpin.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=970496307465, token='201e3256638c0e852686773ce1d89f3829b6e60c82af1cb4ebd96d9faaa6500d', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1559910230699, ownerMembers=[970496307465], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bac1f0>
ctx = None

    @iteration3
    def testInvalidToken(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unpin.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testSuccessfulUnreactInChannel ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=766503927674, token='b3a691a222b05de202713046c4f9b77c1b2adbe40135909a00506cf57f27ccce', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=164489642321, token='cbba0f21e9869cd85c236400ffcdcdf379a5f4a9de3eabf5d23c3cf8c3844058', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1234369978788, ownerMembers=[766503927674], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47dbe1f0>
ctx = None

    @iteration3
    def testSuccessfulUnreactInChannel(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unreact.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________________ testInvalidReactId ______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1261907928827, token='060071f9eda4886046815a332f34f4ffe0da4ff925d649fee5c0fc22a05c483a', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1141703044182, ownerMembers=[1261907928827], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47cc2ee0>
ctx = None

    @iteration3
    def testInvalidReactId(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unreact.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testCantUnreactTwice _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1023837172575, token='449cbe729f0736c57f3c5637cd29f2cf085c1add996da85f5da034a1b440fb18', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=685989598993, ownerMembers=[1023837172575], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bac3a0>
ctx = None

    @iteration3
    def testCantUnreactTwice(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unreact.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testNonmemberCannotUnreact __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1315639275379, token='2e955916618f515e5da12ae999020b00335183d70fea6fdd88b71faea78ce4e0', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=718950367223, token='b476826be667bfe80c118e971fa640ca5fa2c63cefd0068a3d317c0e0840026e', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=854709046915, ownerMembers=[1315639275379], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bac700>
ctx = None

    @iteration3
    def testNonmemberCannotUnreact(userWoody, userZerg, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unreact.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=257093150906, token='2642029e5986c80ef8fb3915dd7586aeb02e2210d5132bb71f3532dc4d999e4a', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=844868976770, ownerMembers=[257093150906], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47ce15e0>
ctx = None

    @iteration3
    def testInvalidToken(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/messageTests/test_message_unreact.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________________ testClearWorks ________________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1657919590812, token='d27793cc31a0180b3009a76d76669400b4cce56de5632955eb0f634c23ace685', handleStr='')
userFactory = <function userFactory.<locals>.makeUser at 0x7fca47ce1550>
ctx = None

    def testClearWorks(userWoody, userFactory, ctx):
        # an existing user can do something
>       assert usersAll(userWoody.token, ctx) is not None

httpTests/otherTests/test_clear.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/other.py:11: in usersAll
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________ testTagThruMessageSendTriggersNotification __________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=734206224557, token='4ffd32c62da417d3c2cfc6ed23d37c715ba56800682954cd5210e4f3b83dd134', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=315817188577, token='3c777f8e9cc7793002930df3193b152aa5dd11033b847f8d6e0cd51b6da04823', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=846687408884, ownerMembers=[734206224557], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c59280>
ctx = None

    @iteration3
    def testTagThruMessageSendTriggersNotification(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testTagNotInChannel ______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=239396937871, token='6db89890945664cf34d03542269d03f6cf4f1a4e0a902d4ad837ec3490b9a878', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=588714589214, token='f78d4f2cbdf120e40069e792046819d8334c18ad893b77c408196a8db194f793', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1113625816867, ownerMembers=[239396937871], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47cc25e0>
ctx = None

    @iteration3
    def testTagNotInChannel(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
        content = f'@{userBuzz.handleStr} hi'
>       messageFactory(userWoody, woodysPublicToybox, content)

httpTests/otherTests/test_notifications_get.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________ testMultipleSameTagsOnlyOneNotification ____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1179315038712, token='bd6c789c3db2ece2f7e21c27b0fb4be372496230508ebaae34e3d049d027f065', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1556943808201, token='b4b5d15188a79a1145ccd3758ca3e89db04eaf9290664f2f79e0accebc3affff', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=421079711913, ownerMembers=[1179315038712], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bbe4c0>
ctx = None

    @iteration3
    def testMultipleSameTagsOnlyOneNotification(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________________ testTagSelf __________________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1527621141351, token='abb6336aea67d7695dcff57f82c639ed558c5edb6a383234fd14997b3814bfb0', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=311962533842, ownerMembers=[1527621141351], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b68040>
ctx = None

    @iteration3
    def testTagSelf(userWoody, woodysPublicToybox, messageFactory, ctx):
        content = f'@{userWoody.handleStr} hi'
>       messageFactory(userWoody, woodysPublicToybox, content)

httpTests/otherTests/test_notifications_get.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testMultipleTags _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1349269865514, token='9ab83d6e3dd2d109db832eb38741e7f03c6d32dcdad9564e0a0d52877b441808', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1180091882922, token='7e402c9ef8abb09b0dd69509e36d1a261f6854071dc5b7242aad02666e513d5d', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=191940568442, token='ef0d40dd40053eefe62660845188c2781483b92aa23cb5db0de5367be700849e', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1272497955700, ownerMembers=[1349269865514], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b7a9d0>
ctx = None

    @iteration3
    def testMultipleTags(userWoody, userBuzz, userZerg, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________ testTagThruMessageSenddmTriggersNotification _________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=662273654989, token='d60717f21cb4ffcfcb36053b1b9025febfcc87663e6ce2b55e8722d664a7059c', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=980048143369, token='6b173e0b7ad8ee4dffcaa3be6961a3e20f6aaa11d4cc4f8ac0fe141a43efe2d9', handleStr='')
woodyAndBuzzDm = DM(owner=662273654989, members=[980048143369], name="'buzzlightyear, sheriffwoody'", dmId=23822418853)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c63e50>
ctx = None

    @iteration3
    def testTagThruMessageSenddmTriggersNotification(userWoody, userBuzz, woodyAndBuzzDm, messageFactory, ctx):
        content = f'@{userWoody.handleStr} hi'
        messageFactory(userBuzz, woodyAndBuzzDm, content)
    
        notifs = notificationsGet(userWoody.token, ctx)
    
>       assert notifs == {'notifications': [{
            'channelId': -1,
            'dmId': woodyAndBuzzDm.dmId,
            'notificationMessage': f'{userBuzz.handleStr} tagged you in {woodyAndBuzzDm.name}: {content[:20]}'
        }]}
E       assert {'notifications': []} == {'notifications': [{'channelId': -1,\n                    'dmId': 23822418853,\n                    'notificationMessage': " tagged you in 'buzzlightyear, "\n                                           "sheriffwoody': @ hi"}]}
E         Differing items:
E         {'notifications': []} != {'notifications': [{'channelId': -1, 'dmId': 23822418853, 'notificationMessage': " tagged you in 'buzzlightyear, sheriffwoody': @ hi"}]}
E         Full diff:
E           {
E         +  'notifications': [],
E         -  'notifications': [{'channelId': -1,
E         -                     'dmId': 23822418853,
E         -                     'notificationMessage': " tagged you in 'buzzlightyear, "
E         -                                            "sheriffwoody': @ hi"}],
E           }

httpTests/otherTests/test_notifications_get.py:110: AssertionError
__________________ testTagThruMessageEditTriggersNotification __________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=703302631967, token='f1e81e0b176e85950be0721b1113a408cfd1702c3921cc9e87ed042eb1080250', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1444265342260, token='6cfba487c2b02d3df0295bae0af9aae029674786bae56ec381199e2232527ce8', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1577251782567, ownerMembers=[703302631967], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c65a60>
ctx = None

    @iteration3
    def testTagThruMessageEditTriggersNotification(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________ testTagThruMessageShareTriggersNotification __________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=14354920268, token='9314c939e0cc980195bcffcb9db13696c983dd6afb18892e2d28eb2a15bc5ca9', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=225082543434, token='89ef65d598e3f93dcf7b1f1c18a7041d0b1cd689814390e06dbded3c1b7afe3e', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=995157437890, ownerMembers=[14354920268], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c00e50>
ctx = None

    @iteration3
    def testTagThruMessageShareTriggersNotification(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________ testTagThruMessageSendlaterTriggersNotification ________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=798773513569, token='7bc93adebb93b8fc9e844d94bf88e42311a3fe409a2b3de18d1e5d67a384c5af', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1447162975428, token='fb7bfecc7f38d015ea20921845b073d4311afffc0bcea4fb44c111c3e4837444', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=79391604553, ownerMembers=[798773513569], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b8d280>
ctx = None

    @iteration3
    def testTagThruMessageSendlaterTriggersNotification(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________ testMessageSendlaterTagNotifiesWhenSent ____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=141710325683, token='663d2ed0b4594cb06bd96eb6c30e928a62cc669d05538c130a039795e53948ef', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1572036308633, token='fa0927d30c258a92999d4b85aa460d29c48edae8e5e1994a7783488a719a921b', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=118843079834, ownerMembers=[141710325683], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b8d940>
ctx = None

    @iteration3
    def testMessageSendlaterTagNotifiesWhenSent(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________ testTagThruMessageSendlaterdmTriggersNotification _______________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=433983742898, token='63369c27b44d853969414b55ea640f8b2788bdc8b5e750de8da96f13136837da', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=145820225004, token='170e7fdef83f157418a72e2462e8d9ec2c87b11cc44f21bf1e606b5b4f51977f', handleStr='')
woodyAndBuzzDm = DM(owner=433983742898, members=[145820225004], name="'buzzlightyear, sheriffwoody'", dmId=740772075490)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c00e50>
ctx = None

    @iteration3
    def testTagThruMessageSendlaterdmTriggersNotification(userWoody, userBuzz, woodyAndBuzzDm, messageFactory, ctx):
        content = f'@{userWoody.handleStr} hi'
        messageFactory(userBuzz, woodyAndBuzzDm, content, delay=1)
    
        sleep(2)
    
        notifs = notificationsGet(userWoody.token, ctx)
    
>       assert notifs == {'notifications': [{
            'channelId': -1,
            'dmId': woodyAndBuzzDm.dmId,
            'notificationMessage': f'{userBuzz.handleStr} tagged you in {woodyAndBuzzDm.name}: {content[:20]}'
        }]}
E       assert {'notifications': []} == {'notifications': [{'channelId': -1,\n                    'dmId': 740772075490,\n                    'notificationMessage': " tagged you in 'buzzlightyear, "\n                                           "sheriffwoody': @ hi"}]}
E         Differing items:
E         {'notifications': []} != {'notifications': [{'channelId': -1, 'dmId': 740772075490, 'notificationMessage': " tagged you in 'buzzlightyear, sheriffwoody': @ hi"}]}
E         Full diff:
E           {
E         +  'notifications': [],
E         -  'notifications': [{'channelId': -1,
E         -                     'dmId': 740772075490,
E         -                     'notificationMessage': " tagged you in 'buzzlightyear, "
E         -                                            "sheriffwoody': @ hi"}],
E           }

httpTests/otherTests/test_notifications_get.py:208: AssertionError
___________ testTagNotificationMessagePreviewLength[a small message] ___________

content = 'a small message'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1599846140635, token='2620ec15ca4717e084d04cac05a2ac66ce1d83d925e6e229015b3a53b5c3ab40', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=186839261941, token='c94118d3b2a03c9d2d374ba9ee0763bc6d21317e9742327d6bdfc3cdf3cf68e6', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1014261661179, ownerMembers=[1599846140635], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b8d700>
ctx = None

    @iteration3
    @pytest.mark.parametrize('content', ['a small message', 'AAAAAAA' * 50])
    def testTagNotificationMessagePreviewLength(content, userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_ testTagNotificationMessagePreviewLength[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] _

content = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1333424853014, token='448677a356a12bd7a0b6b541ade70263ff79798ca6df09ccb1882d394ec54757', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=902750757248, token='abf0ce94992450c243e84a7f622a86bd0a8f79b53e8e084e8b34a4c33421c193', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=233230637549, ownerMembers=[1333424853014], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b23a60>
ctx = None

    @iteration3
    @pytest.mark.parametrize('content', ['a small message', 'AAAAAAA' * 50])
    def testTagNotificationMessagePreviewLength(content, userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testReactTriggersNotification[ch] _______________________

dest = 'ch'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=396559442550, token='af0a8e3f849c280b5ee4556cfdd1cb9176df0aada6b376ce8fb44ca64191eb3d', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=382279802081, token='778b5fef62387cefd0f36104b4caa0a4cc05ad7b62c7df4e9b7901563045968a', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=374494660252, ownerMembers=[396559442550], allMembers=[])
woodyAndBuzzDm = DM(owner=396559442550, members=[382279802081], name="'buzzlightyear, sheriffwoody'", dmId=204739322283)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c658b0>
ctx = None

    @iteration3
    @pytest.mark.parametrize('dest', ['ch', 'dm'])
    def testReactTriggersNotification(dest, userWoody, userBuzz, woodysPublicToybox, woodyAndBuzzDm, messageFactory, ctx):
        if dest == 'ch':
>           channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testReactTriggersNotification[dm] _______________________

dest = DM(owner=1219383601191, members=[486861558767], name="'buzzlightyear, sheriffwoody'", dmId=1197339560018)
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1219383601191, token='036a2a225036cb32be9ec43a9f1275c8caa1469fcdf63500135b1d333f4cebd2', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=486861558767, token='27d652ac3c1a6323d4d761769de03ed2ba81fb364ab6c0731951f0f88a4cf788', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=722561153882, ownerMembers=[1219383601191], allMembers=[])
woodyAndBuzzDm = DM(owner=1219383601191, members=[486861558767], name="'buzzlightyear, sheriffwoody'", dmId=1197339560018)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47bbe310>
ctx = None

    @iteration3
    @pytest.mark.parametrize('dest', ['ch', 'dm'])
    def testReactTriggersNotification(dest, userWoody, userBuzz, woodysPublicToybox, woodyAndBuzzDm, messageFactory, ctx):
        if dest == 'ch':
            channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)
    
        dest = woodysPublicToybox if dest == 'ch' else woodyAndBuzzDm
    
        aMsg = messageFactory(userWoody, dest)
    
        messageReact(userBuzz.token, aMsg.messageId, 1, ctx)
    
        notifs = notificationsGet(userWoody.token, ctx)
    
>       assert notifs == {'notifications': [{
            'channelId': woodysPublicToybox.channelId if dest == woodysPublicToybox else -1,
            'dmId': woodyAndBuzzDm.dmId if dest == woodyAndBuzzDm else -1,
            'notificationMessage': f'{userBuzz.handleStr} reacted to your message in {dest.name}'
        }]}
E       assert {'notifications': [{'channelId': -1,\n                    'dmId': 1197339560018,\n                    'notificationMessage': 'buzzlightyear reacted to your '\n                                           "message in 'buzzlightyear, "\n                                           "sheriffwoody'"}]} == {'notifications': [{'channelId': -1,\n                    'dmId': 1197339560018,\n                    'notificationMessage': ' reacted to your message in '\n                                           "'buzzlightyear, sheriffwoody'"}]}
E         Differing items:
E         {'notifications': [{'channelId': -1, 'dmId': 1197339560018, 'notificationMessage': "buzzlightyear reacted to your message in 'buzzlightyear, sheriffwoody'"}]} != {'notifications': [{'channelId': -1, 'dmId': 1197339560018, 'notificationMessage': " reacted to your message in 'buzzlightyear, sheriffwoody'"}]}
E         Full diff:
E           {
E            'notifications': [{'channelId': -1,
E                               'dmId': 1197339560018,
E         -                     'notificationMessage': ' reacted to your message in '
E         ?                                                              -----------
E         +                     'notificationMessage': 'buzzlightyear reacted to your '
E         ?                                             +++++++++++++
E         +                                            "message in 'buzzlightyear, "
E         -                                            "'buzzlightyear, sheriffwoody'"}],
E         ?                                             ----------------
E         +                                            "sheriffwoody'"}],
E           }

httpTests/otherTests/test_notifications_get.py:248: AssertionError
___________________ testAddThruChInviteTriggersNotification ____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1163134577586, token='0aab80279e88c99282f7575289c3922936157a81abf8b4dae1bae72efa994b08', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=213057923526, token='cbcf97dd218593f47839086f149dda997d19bfaebd80a6ce3c4cec85a8474fbc', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1296290951718, ownerMembers=[1163134577586], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c630d0>
ctx = None

    @iteration3
    def testAddThruChInviteTriggersNotification(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________ testAddThruDmCreateTriggersNotification ____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1420081305074, token='53795747dcc7177042927f76c4bac9bdfd9276addda1d52bca939e9f02d42c83', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=308853236209, token='4ff0695c89cb9bcfffa1c56fff574e0428a384d886375b5d1021541925f5f93a', handleStr='')
woodyAndBuzzDm = DM(owner=1420081305074, members=[308853236209], name="'buzzlightyear, sheriffwoody'", dmId=15616526316)
ctx = None

    @iteration3
    def testAddThruDmCreateTriggersNotification(userWoody, userBuzz, woodyAndBuzzDm, ctx):
        buzzsNotifs = notificationsGet(userBuzz.token, ctx)
    
>       assert buzzsNotifs == {'notifications': [{
            'channelId': -1,
            'dmId': woodyAndBuzzDm.dmId,
            'notificationMessage': f'{userWoody.handleStr} added you to {woodyAndBuzzDm.name}'
        }]}
E       assert {'notifications': [{'channelId': -1,\n                    'dmId': 15616526316,\n                    'notificationMessage': 'sheriffwoody added you to '\n                                           "'buzzlightyear, sheriffwoody'"}]} == {'notifications': [{'channelId': -1,\n                    'dmId': 15616526316,\n                    'notificationMessage': " added you to 'buzzlightyear, "\n                                           "sheriffwoody'"}]}
E         Differing items:
E         {'notifications': [{'channelId': -1, 'dmId': 15616526316, 'notificationMessage': "sheriffwoody added you to 'buzzlightyear, sheriffwoody'"}]} != {'notifications': [{'channelId': -1, 'dmId': 15616526316, 'notificationMessage': " added you to 'buzzlightyear, sheriffwoody'"}]}
E         Full diff:
E           {
E            'notifications': [{'channelId': -1,
E                               'dmId': 15616526316,
E         -                     'notificationMessage': " added you to 'buzzlightyear, "
E         ?                                            ^               ----------------
E         +                     'notificationMessage': 'sheriffwoody added you to '
E         ?                                            ^^^^^^^^^^^^^
E         -                                            "sheriffwoody'"}],
E         +                                            "'buzzlightyear, sheriffwoody'"}],
E         ?                                             ++++++++++++++++
E           }

httpTests/otherTests/test_notifications_get.py:272: AssertionError
____________________ testMostRecent_20NotificationsFetched _____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=372169184669, token='11bccf50fc1f66f12f73361e057797aae124c26fc931d12e73f5f92b82d26562', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=462556371591, token='948f11e7a8da52790319a3c64d60d10352c6488880650d685c9308fbbde8f660', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1373229196294, ownerMembers=[372169184669], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c63160>
ctx = None

    @iteration3
    def testMostRecent_20NotificationsFetched(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
>       channelInvite(userWoody.token, woodysPublicToybox.channelId, userBuzz.uId, ctx)

httpTests/otherTests/test_notifications_get.py:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testSingleMatch ________________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1499007090977, token='41d0ebfcb985d04e452aaed8dc9befe130492dbdd4f734e9987b1f2cd60065b8', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1051105517947, ownerMembers=[1499007090977], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c41670>
ctx = None

    @iteration3
    def testSingleMatch(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox, 'anything')

httpTests/otherTests/test_search.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testCaseInsensitiveMatch ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=450898425328, token='faade2ea1af4b97bc8d6c51dce9d11e07f4c99a2b875b609aca91e4aaf8bd3e1', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=24469385252, ownerMembers=[450898425328], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c65430>
ctx = None

    @iteration3
    def testCaseInsensitiveMatch(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox, 'AnYthing')

httpTests/otherTests/test_search.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testMultipleMatches ______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=59638852277, token='4e939570c3613abfdddf18ced6fbcfcd6163f97093560c99906ba7170fa77b6e', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=717381768971, ownerMembers=[59638852277], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47ce13a0>
ctx = None

    @iteration3
    def testMultipleMatches(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox, 'any 1')

httpTests/otherTests/test_search.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testMultipleChannelsJoined __________________________

userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=510400124294, token='92ede8fc497096cdc0b8b566ba69f26d5b57029133e0aa3f3a2381f0daf428f1', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1646129031339, ownerMembers=[428692049580], allMembers=[])
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=1092457305990, ownerMembers=[510400124294], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47cea160>
ctx = None

    @iteration3
    def testMultipleChannelsJoined(userZerg, woodysPublicToybox, zergsPrivateLair, messageFactory, ctx):
        channelJoin(userZerg.token, woodysPublicToybox.channelId, ctx)
    
>       inWoody = messageFactory(userZerg, woodysPublicToybox, 'any 1')

httpTests/otherTests/test_search.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________ testSearchIncludesOnlyJoinedChannels _____________________

userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=709673358507, token='94591c3ff967899d6c6a763d956b59f1cc8ce2f723bd0bfa581f7e29daaa519f', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1311396284615, ownerMembers=[1433280403249], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b683a0>
ctx = None

    @iteration3
    def testSearchIncludesOnlyJoinedChannels(userBuzz, woodysPublicToybox, messageFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
>       messageFactory(userBuzz, woodysPublicToybox, 'anything')

httpTests/otherTests/test_search.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________ testSearchMatchesMoreThanJustAuthorisedUser __________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=627797531265, token='2629396a2499631334dedaa8e76f8de2ec92b189a0eefcaebe78259d457bb6bd', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1241418308949, token='492f4f1e6bf3044eaacb8c871a6314eba0ccc9e0058e29840258c6a0cc666d9d', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=281223551319, ownerMembers=[627797531265], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c41e50>
ctx = None

    @iteration3
    def testSearchMatchesMoreThanJustAuthorisedUser(userWoody, userBuzz, woodysPublicToybox, messageFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
>       messageFactory(userBuzz, woodysPublicToybox, 'hi')

httpTests/otherTests/test_search.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testSuccessfulUsersAll ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1452259499749, token='262cdaea27b3f88ccfbb9e0ad6d60e6401957487f765885a131ab42b278a208f', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=574974946147, token='c5e22e4f7a727970e0b6756257ae7ed0d4ef50dd134a8d190c51f20479b70aba', handleStr='')
ctx = None

    def testSuccessfulUsersAll(userWoody, userBuzz, ctx):
>       users = usersAll(userWoody.token, ctx)['users']

httpTests/otherTests/test_users_all.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/other.py:11: in usersAll
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1501826347331, token='a4c9b9bab8d51b852746dd1bd818e6f625d4457ea7582d16a262f68effd4099a', handleStr='')
ctx = None

    def testInvalidToken(userWoody, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           usersAll(userWoody.token, ctx)

httpTests/otherTests/test_users_all.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/other.py:11: in usersAll
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testCorrectReturnFormat[True] _________________________

doStandup = True
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=284375907051, token='c7efd20738a7d909e78f93016920fb732a3d561f1c3df1289465d9515a7ca7c6', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=468097891498, ownerMembers=[284375907051], allMembers=[])
standupFactory = <function standupFactory.<locals>.makeStandup at 0x7fca47b4d8b0>
ctx = None

    @iteration3
    @pytest.mark.parametrize('doStandup', [True, False])
    def testCorrectReturnFormat(doStandup, userWoody, woodysPublicToybox, standupFactory, ctx):
        if doStandup:
            standupFactory(userWoody, woodysPublicToybox)
    
        r = standupActive(userWoody.token, woodysPublicToybox.channelId, ctx)
    
        assert 'isActive' in r and isinstance(r['isActive'], bool)
>       assert 'timeFinish' in r and (type(r['timeFinish']) is int if doStandup else type(r['timeFinish'] is None))
E       AssertionError: assert ('timeFinish' in {'isActive': True, 'timeFinish': 0.994999885559082} and False)

httpTests/standupTests/test_standup_active.py:25: AssertionError
__________________ testMessagesBufferedAndDisplayedCorrectly ___________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1010531912491, token='a0e91a27c14dfe611c6d99b27925ff60a3c276f6860acffef9f1f728b0b568c8', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1120336507060, token='cd818e6594f7a7a440889991b383a8aa98373d3717839eb08b2731e647670548', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=821520474811, ownerMembers=[1010531912491], allMembers=[])
standupFactory = <function standupFactory.<locals>.makeStandup at 0x7fca47ca0550>
ctx = None

    @iteration3
    def testMessagesBufferedAndDisplayedCorrectly(userWoody, userBuzz, woodysPublicToybox, standupFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
    
        std = standupFactory(userWoody, woodysPublicToybox, 1)
    
        standupSend(userWoody.token, woodysPublicToybox.channelId, 'welcome', ctx)
        standupSend(userBuzz.token, woodysPublicToybox.channelId, 'to the', ctx)
        standupSend(userWoody.token, woodysPublicToybox.channelId, 'black parade', ctx)
    
        sleep(2)
    
>       chMsgs = channelMessages(userWoody.token, woodysPublicToybox.channelId, 0, ctx)['messages']

httpTests/standupTests/test_standup_send.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testStandupSendsAfterLoggedOut ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=288253761076, token='6e07651307c382d8b2fef87f2b158c72d3a66b8f2826e13cbd2d5ef9aa15569a', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1623214077588, token='4256fa419c720a5bd10921c80ec56a3b8e2a7ae1f19e0062e896c31d7cca677c', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=170522330885, ownerMembers=[288253761076], allMembers=[])
standupFactory = <function standupFactory.<locals>.makeStandup at 0x7fca47bac700>
ctx = None

    @iteration3
    def testStandupSendsAfterLoggedOut(userWoody, userBuzz, woodysPublicToybox, standupFactory, ctx):
        channelJoin(userBuzz.token, woodysPublicToybox.channelId, ctx)
        std = standupFactory(userWoody, woodysPublicToybox, 2)
    
        standupSend(userWoody.token, woodysPublicToybox.channelId, 'hello', ctx)
    
        authLogout(userWoody.token, ctx)
    
        sleep(2)
    
>       chMsgs = channelMessages(userBuzz.token, woodysPublicToybox.channelId, 0, ctx)['messages']

httpTests/standupTests/test_standup_send.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testStandupNoMessages _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=572410640432, token='f5fc6b2ca8e4c131b901c7638a52f492766a36290cab51844fe5c8c8be223c56', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=88317243757, ownerMembers=[572410640432], allMembers=[])
ctx = None

    @iteration3
    def testStandupNoMessages(userWoody, woodysPublicToybox, ctx):
        ret = standupStart(userWoody.token, woodysPublicToybox.channelId, 1, ctx)
    
        sleep(2)
    
>       chMsgs = channelMessages(userWoody.token, woodysPublicToybox.channelId, 0, ctx)

httpTests/standupTests/test_standup_start.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:38: in channelMessages
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________ testStandupRestartableAfterLapse _______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=306043415269, token='d21d76303f502246655a74482c0e995f888ddca8d8a164aea87ec9c0be3f83b2', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=874604672761, ownerMembers=[306043415269], allMembers=[])
ctx = None

    @iteration3
    def testStandupRestartableAfterLapse(userWoody, woodysPublicToybox, ctx):
        standupStart(userWoody.token, woodysPublicToybox.channelId, 1, ctx)
        sleep(2)
    
>       assert standupStart(userWoody.token, woodysPublicToybox.channelId, 1, ctx) is not None

httpTests/standupTests/test_standup_start.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/standup.py:11: in standupStart
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [400]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
>           raise error.InputError()
E           httpTests.error.InputError: 400 Bad Request: None

httpTests/fakepi/util.py:93: InputError
____________________________ testReturnTypeCorrect _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1037569780385, token='8cda385a0775d4712fa03b2571e55bc560b2c9a587070bb28fa4e4dc0faa97f1', handleStr='')
ctx = None

    @iteration3
    def testReturnTypeCorrect(userWoody, ctx):
        stats = userStats(userWoody.token, ctx)
    
        assert 'userStats' in stats
        stats = stats['userStats']
    
        assert 'channelsJoined' in stats and isinstance(stats['channelsJoined'], list)
        assert stats['channelsJoined'][-1]['numChannelsJoined'] == 0
        assert abs(stats['channelsJoined'][-1]['timeStamp'] - utcNow()) <= 2
    
        assert 'dmsJoined' in stats and isinstance(stats['dmsJoined'], list)
>       assert stats['dmsJoined'][-1]['numSmsJoined'] == 0
E       KeyError: 'numSmsJoined'

httpTests/statsTests/test_user_stats.py:31: KeyError
_______________________ testChannelsTrackedChannelInvite _______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=648978205256, token='1b8c57efbdc798946b8cccf0f41815ebd0d4bad2b01a9daacc49338589261b72', handleStr='')
userZerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', nameFirst='lord', nameLast='zerg', uId=502194440802, token='99b5cb4680cf36a391ec02f0be65639b54b009863f9c7f5abaa3ce9243a885cc', handleStr='')
zergsPrivateLair = Channel(name='zergs lair', isPublic=False, channelId=734136972726, ownerMembers=[502194440802], allMembers=[])
ctx = None

    @iteration3
    def testChannelsTrackedChannelInvite(userWoody, userZerg, zergsPrivateLair, ctx):
>       channelInvite(userZerg.token, zergsPrivateLair.channelId, userWoody.uId, ctx)

httpTests/statsTests/test_user_stats.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:12: in channelInvite
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________ testChannelsTrackedChannelLeave ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=65478711485, token='b00c0164cd50ee9e22b0f3d077307595665ed4381ddd2db9029e0bc67f1cde04', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=756355701602, ownerMembers=[65478711485], allMembers=[])
ctx = None

    @iteration3
    def testChannelsTrackedChannelLeave(userWoody, woodysPublicToybox, ctx):
>       channelLeave(userWoody.token, woodysPublicToybox.channelId, ctx)

httpTests/statsTests/test_user_stats.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/channel.py:51: in channelLeave
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testSmsTrackedSmCreate ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=373738925615, token='80353042da2ee6fea8f74f65fb37d104cb888b8d77df36add6bb08b8a5b326ae', handleStr='')
dmFactory = <function dmFactory.<locals>.makeDm at 0x7fca47c59f70>, ctx = None

    @iteration3
    def testSmsTrackedSmCreate(userWoody, dmFactory, ctx):
        dmFactory(userWoody, [])
    
        dmStats = userStats(userWoody.token, ctx)['userStats']['dmsJoined']
    
        assert len(dmStats) == 2
>       assert dmStats[-1]['numSmsJoined'] == 1
E       KeyError: 'numSmsJoined'

httpTests/statsTests/test_user_stats.py:92: KeyError
________________________ testMessagesTrackedMessageSend ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=465394928055, token='8c54dc20fc729d727f208599e6e2eb9a16df0b1b73b6b3c5923d6a2c5d7f0e7b', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=176589214813, ownerMembers=[465394928055], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b7aee0>
ctx = None

    @iteration3
    def testMessagesTrackedMessageSend(userWoody, woodysPublicToybox, messageFactory, ctx):
>       messageFactory(userWoody, woodysPublicToybox)

httpTests/statsTests/test_user_stats.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________ testMessagesTrackedMessageSendlater ______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=264382250837, token='4f0f531443810e38d08cb472ecfc6253ebfe95a7ebdfec073a2f9d60c26cc849', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1227689285198, ownerMembers=[264382250837], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47b32820>
ctx = None

    @iteration3
    def testMessagesTrackedMessageSendlater(userWoody, woodysPublicToybox, messageFactory, ctx):
        messageFactory(userWoody, woodysPublicToybox, delay=1)
    
        sleep(1.5)
    
        msgStats = userStats(userWoody.token, ctx)['userStats']['messagesSent']
    
>       assert len(msgStats) == 2
E       assert 1 == 2
E         +1
E         -2

httpTests/statsTests/test_user_stats.py:139: AssertionError
_______________________ testMessagesTrackedMessageShare ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=70280570836, token='2d06a74e98f9ce95c2e9803240e698f37ee6c6af5222a243f057ae2a45a9293b', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1278956814613, ownerMembers=[70280570836], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47af31f0>
ctx = None

    @iteration3
    def testMessagesTrackedMessageShare(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/statsTests/test_user_stats.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testReturnTypeCorrect _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=307630741909, token='e0e7bcdae0568977c8f5327eb95120740728b06e88e05ea3c3ef661982e875a9', handleStr='')
ctx = None

    @iteration3
    def testReturnTypeCorrect(userWoody, ctx):
        stats = usersStats(userWoody.token, ctx)
    
        assert 'workspaceStats' in stats
        stats = stats['workspaceStats']
    
        assert 'channelsExist' in stats and isinstance(stats['channelsExist'], list)
        assert len(stats['channelsExist']) == 1
        assert stats['channelsExist'][-1]['numChannelsExist'] == 0
        assert abs(stats['channelsExist'][-1]['timeStamp'] - utcNow()) <= 2
    
        assert 'dmsExist' in stats and isinstance(stats['dmsExist'], list)
        assert len(stats['dmsExist']) == 1
        assert stats['dmsExist'][-1]['numDmsExist'] == 0
        assert abs(stats['dmsExist'][-1]['timeStamp'] - utcNow()) <= 2
    
        assert 'messagesExist' in stats and isinstance(stats['messagesExist'], list)
        assert len(stats['messagesExist']) == 1
        assert stats['messagesExist'][-1]['numMessagesExist'] == 0
        assert abs(stats['messagesExist'][-1]['timeStamp'] - utcNow()) <= 2
    
>       assert 'utilizationRate' in stats and isinstance(stats['utilizationRate'], float)
E       AssertionError: assert ('utilizationRate' in {'channelsExist': [{'numChannelsExist': 0, 'timeStamp': 1659756003}], 'dmsExist': [{'numDmsExist': 0, 'timeStamp': 1659756003}], 'messagesExist': [{'numMessagesExist': 0, 'timeStamp': 1659756003}], 'utilizationRate': 0} and False)
E        +  where False = isinstance(0, float)

httpTests/statsTests/test_users_stats.py:40: AssertionError
________________________ testMessagesTrackedMessageSend ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=886969502002, token='43e70f21dfb9686e02d4384c591e6626547445aa2cfaa3cd471d46dfd32cb22f', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=715191118553, ownerMembers=[886969502002], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c14f70>
ctx = None

    @iteration3
    def testMessagesTrackedMessageSend(userWoody, woodysPublicToybox, messageFactory, ctx):
>       messageFactory(userWoody, woodysPublicToybox)

httpTests/statsTests/test_users_stats.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________ testMessagesTrackedMessageSendlater ______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=756790211997, token='ad680e0578cb0ca370507e53ec8765cd82e22fb345a9972f66a5660cc7b65db7', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1606976250708, ownerMembers=[756790211997], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c594c0>
ctx = None

    @iteration3
    def testMessagesTrackedMessageSendlater(userWoody, woodysPublicToybox, messageFactory, ctx):
        messageFactory(userWoody, woodysPublicToybox, delay=1)
    
        sleep(1.5)
    
        msgStats = usersStats(userWoody.token, ctx)['workspaceStats']['messagesExist']
    
>       assert len(msgStats) == 2
E       assert 1 == 2
E         +1
E         -2

httpTests/statsTests/test_users_stats.py:96: AssertionError
____________________ testMessagesTrackedMessageSenddmlater _____________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1171699095581, token='d05210dc14f11ac4aa6254162666f09efbb69b3997e9b78d74cc8303f49c4e2e', handleStr='')
woodyAndBuzzDm = DM(owner=1171699095581, members=[853342562258], name="'buzzlightyear, sheriffwoody'", dmId=1216633429782)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47d27d30>
ctx = None

    @iteration3
    def testMessagesTrackedMessageSenddmlater(userWoody, woodyAndBuzzDm, messageFactory, ctx):
        messageFactory(userWoody, woodyAndBuzzDm, delay=1)
    
        sleep(1.5)
    
        msgStats = usersStats(userWoody.token, ctx)['workspaceStats']['messagesExist']
    
>       assert len(msgStats) == 2
E       assert 1 == 2
E         +1
E         -2

httpTests/statsTests/test_users_stats.py:120: AssertionError
_______________________ testMessagesTrackedMessageShare ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1547675316390, token='09f6afd114d8b2c9c80fe7155eb418ff34f7da12bd169ea14f8b7011d7e88ec8', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=966423710676, ownerMembers=[1547675316390], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c59ca0>
ctx = None

    @iteration3
    def testMessagesTrackedMessageShare(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/statsTests/test_users_stats.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testMessagesTrackedEditedToRemoval ______________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=206966319817, token='93b46699bf3e7eca30d8454a6f4d4afb7b1f3015e9dc1e7b42506f826fbf0ca0', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=1512698683970, ownerMembers=[206966319817], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c63a60>
ctx = None

    @iteration3
    def testMessagesTrackedEditedToRemoval(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/statsTests/test_users_stats.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testMessagesTrackedDeleted __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=851911171435, token='78deeacd03fd43970ac054c96901da97119c15d7ff0fc6981292a100245e1a3a', handleStr='')
woodysPublicToybox = Channel(name='woodys toybox', isPublic=True, channelId=588460817590, ownerMembers=[851911171435], allMembers=[])
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47c59160>
ctx = None

    @iteration3
    def testMessagesTrackedDeleted(userWoody, woodysPublicToybox, messageFactory, ctx):
>       aMsg = messageFactory(userWoody, woodysPublicToybox)

httpTests/statsTests/test_users_stats.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fixtures.py:106: in makeMessage
    msgId = message.messageSend(poster.token, location.channelId, content, ctx)['messageId']
httpTests/fakepi/message.py:11: in messageSend
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testMessagesTrackedDmRemoved _________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1223260554838, token='0e9562e1e5f864c17132edc26b091f5e2a3f6744275f38a4730077dc33b6881e', handleStr='')
woodyAndBuzzDm = DM(owner=1223260554838, members=[989788087237], name="'buzzlightyear, sheriffwoody'", dmId=1142598110524)
messageFactory = <function messageFactory.<locals>.makeMessage at 0x7fca47cc25e0>
ctx = None

    @iteration3
    def testMessagesTrackedDmRemoved(userWoody, woodyAndBuzzDm, messageFactory, ctx):
        messageFactory(userWoody, woodyAndBuzzDm)
    
        dmRemove(userWoody.token, woodyAndBuzzDm.dmId, ctx)
    
        msgStats = usersStats(userWoody.token, ctx)['workspaceStats']['messagesExist']
    
>       assert len(msgStats) == 3
E       assert 2 == 3
E         +2
E         -3

httpTests/statsTests/test_users_stats.py:185: AssertionError
_____________________________ testUserProfileValid _____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=61074685967, token='1131fd0bd3ea8b99fecb35eca7faebe1bbf42a798b89267facc9de75ceead770', handleStr='')
ctx = None

    def testUserProfileValid(userWoody, ctx):
>       deets = userProfile(userWoody.token, userWoody.uId, ctx)['user']

httpTests/userTests/test_user_profile.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidUser ________________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=51495544646, token='bd5b88b6ae6fca4cefa9455f929fc88fe9438ff37955ddca8ad42afe7eb88f31', handleStr='')
ctx = None

    def testInvalidUser(userWoody, ctx):
        with pytest.raises(InputError):
>           userProfile(userWoody.token, -1, ctx)

httpTests/userTests/test_user_profile.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1103319115753, token='718a962c7aabc11955836ef7f516b06ad1073197eb2fbd321d2b2dc60109b6a2', handleStr='')
ctx = None

    def testInvalidToken(userWoody, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           userProfile(userWoody.token, userWoody.uId, ctx)

httpTests/userTests/test_user_profile.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:11: in userProfile
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testSuccessfulEmailChange ___________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1295207395391, token='62fb84b7a59ee14a06b74ef6693fab49e946170d2c3687f6b4ecd102cf84b786', handleStr='')
ctx = None

    def testSuccessfulEmailChange(userWoody, ctx):
        newEmail = 'toystory3@pixar.com'
>       userProfileSetemail(userWoody.token, newEmail, ctx)

httpTests/userTests/test_user_profile_setemail.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:37: in userProfileSetemail
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testCannotChangeToTakenEmail _________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=765673040150, token='81e02f6c81ef452aadecd9360c06adba133109282254d044fca6d42c3f531cf2', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1214835682173, token='485869203d6cf4b36a95276756351d74b76640ca83e38271deb795a9e91c6942', handleStr='')
ctx = None

    def testCannotChangeToTakenEmail(userWoody, userBuzz, ctx):
        with pytest.raises(InputError):
>           userProfileSetemail(userWoody.token, userBuzz.email, ctx)

httpTests/userTests/test_user_profile_setemail.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:37: in userProfileSetemail
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________________ testInvalidEmail[] ______________________________

email = ''
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1256033582640, token='d89a62b73e84983294ff8620320fab70a25291af51c2c0bddcbca5ce642b8ea7', handleStr='')
ctx = None

    @pytest.mark.parametrize('email', ['', 'bob', 'ab.com', '@gmail.com', 'ab@ab@gmail.com'])
    def testInvalidEmail(email, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetemail(userWoody.token, email, ctx)

httpTests/userTests/test_user_profile_setemail.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:37: in userProfileSetemail
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testInvalidEmail[bob] _____________________________

email = 'bob'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1568465273299, token='dd7c95abd65c1fd900a9e53800d5f7cd422bd017754e37d167239d2d7f597d19', handleStr='')
ctx = None

    @pytest.mark.parametrize('email', ['', 'bob', 'ab.com', '@gmail.com', 'ab@ab@gmail.com'])
    def testInvalidEmail(email, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetemail(userWoody.token, email, ctx)

httpTests/userTests/test_user_profile_setemail.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:37: in userProfileSetemail
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testInvalidEmail[ab.com] ___________________________

email = 'ab.com'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=482576765657, token='989837b59176a242e0fc3a98c45f5deeacefda37206d4404c0f8c6e2415165b5', handleStr='')
ctx = None

    @pytest.mark.parametrize('email', ['', 'bob', 'ab.com', '@gmail.com', 'ab@ab@gmail.com'])
    def testInvalidEmail(email, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetemail(userWoody.token, email, ctx)

httpTests/userTests/test_user_profile_setemail.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:37: in userProfileSetemail
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testInvalidEmail[@gmail.com] _________________________

email = '@gmail.com'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=14564813107, token='db5650a736b21951923e6ae6c54a15fe8e08e7bff88c73642c467d3690268234', handleStr='')
ctx = None

    @pytest.mark.parametrize('email', ['', 'bob', 'ab.com', '@gmail.com', 'ab@ab@gmail.com'])
    def testInvalidEmail(email, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetemail(userWoody.token, email, ctx)

httpTests/userTests/test_user_profile_setemail.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:37: in userProfileSetemail
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________ testInvalidEmail[ab@ab@gmail.com] _______________________

email = 'ab@ab@gmail.com'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1372570059158, token='86ad623d0020e2bd9ede7b26b1c25663675392dd9079e1b8bde0f7865c01992d', handleStr='')
ctx = None

    @pytest.mark.parametrize('email', ['', 'bob', 'ab.com', '@gmail.com', 'ab@ab@gmail.com'])
    def testInvalidEmail(email, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetemail(userWoody.token, email, ctx)

httpTests/userTests/test_user_profile_setemail.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:37: in userProfileSetemail
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=328142921093, token='af23a4c56765fa77459218666f4c04dd8f8cf2e56e3c00002d99fa123c5967f8', handleStr='')
ctx = None

    def testInvalidToken(userWoody, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           userProfileSetemail(userWoody.token, userWoody.email, ctx)

httpTests/userTests/test_user_profile_setemail.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:37: in userProfileSetemail
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
__________________________ testSuccessfulHandleChange __________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=626626793023, token='83b7a1c2bc891c25ffbfeecdc56ebe8480d690fe19786913fe3bde34b87da15a', handleStr='')
ctx = None

    def testSuccessfulHandleChange(userWoody, ctx):
        newHandle = 'www'
>       userProfileSethandle(userWoody.token, newHandle, ctx)

httpTests/userTests/test_user_profile_sethandle.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testCannotChangeToTakenHandle _________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=409679682802, token='ee2ecf2cc5f282cb0718d8a495756bf3c3aed85ed7ac8628d306685b1e8c76aa', handleStr='')
userBuzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', nameFirst='buzz', nameLast='lightyear', uId=1527572674106, token='6b4807f5a5e2e7544321361c72f1ccc832620a6705be2042fc74b1f778541318', handleStr='')
ctx = None

    def testCannotChangeToTakenHandle(userWoody, userBuzz, ctx):
        with pytest.raises(InputError):
>           userProfileSethandle(userWoody.token, userBuzz.handleStr, ctx)

httpTests/userTests/test_user_profile_sethandle.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testInvalidHandle[] ______________________________

handleStr = ''
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=607682165778, token='9a906a8840a8bfb50a3a483af461375bdf891f3155c9cbb79f1d3d6edfe9af28', handleStr='')
ctx = None

    @pytest.mark.parametrize('handleStr', ['', 'a', 'aa', 'a' * 21, 'new handle', 'newh@ndle'])
    def testInvalidHandle(handleStr, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSethandle(userWoody.token, handleStr, ctx)

httpTests/userTests/test_user_profile_sethandle.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_____________________________ testInvalidHandle[a] _____________________________

handleStr = 'a'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1004311976085, token='c77796266f5d95aecd77b58dc56734145794a78a29721498e3af58c51931c1fd', handleStr='')
ctx = None

    @pytest.mark.parametrize('handleStr', ['', 'a', 'aa', 'a' * 21, 'new handle', 'newh@ndle'])
    def testInvalidHandle(handleStr, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSethandle(userWoody.token, handleStr, ctx)

httpTests/userTests/test_user_profile_sethandle.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____________________________ testInvalidHandle[aa] _____________________________

handleStr = 'aa'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1542387344454, token='f9faaed74cd8ea1de96aefeb6f0d9afab76d30be7e63940a0987a971de9d1856', handleStr='')
ctx = None

    @pytest.mark.parametrize('handleStr', ['', 'a', 'aa', 'a' * 21, 'new handle', 'newh@ndle'])
    def testInvalidHandle(handleStr, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSethandle(userWoody.token, handleStr, ctx)

httpTests/userTests/test_user_profile_sethandle.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________ testInvalidHandle[aaaaaaaaaaaaaaaaaaaaa] ___________________

handleStr = 'aaaaaaaaaaaaaaaaaaaaa'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=541620632059, token='25fe6ea8f9faf3290bf7077951d7fd7686968881e0ce3cbeaac7b118707ac5d1', handleStr='')
ctx = None

    @pytest.mark.parametrize('handleStr', ['', 'a', 'aa', 'a' * 21, 'new handle', 'newh@ndle'])
    def testInvalidHandle(handleStr, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSethandle(userWoody.token, handleStr, ctx)

httpTests/userTests/test_user_profile_sethandle.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
________________________ testInvalidHandle[new handle] _________________________

handleStr = 'new handle'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1361059280032, token='f35e45d23ea9a381f1feb4e2ef6897ffd03c2e8978927d1e9ef4af385eec0373', handleStr='')
ctx = None

    @pytest.mark.parametrize('handleStr', ['', 'a', 'aa', 'a' * 21, 'new handle', 'newh@ndle'])
    def testInvalidHandle(handleStr, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSethandle(userWoody.token, handleStr, ctx)

httpTests/userTests/test_user_profile_sethandle.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_________________________ testInvalidHandle[newh@ndle] _________________________

handleStr = 'newh@ndle'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=128041680685, token='a8b80329961ff061f563b869c4b6e1a02acdbbfc4965120db268ec5946f5ea69', handleStr='')
ctx = None

    @pytest.mark.parametrize('handleStr', ['', 'a', 'aa', 'a' * 21, 'new handle', 'newh@ndle'])
    def testInvalidHandle(handleStr, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSethandle(userWoody.token, handleStr, ctx)

httpTests/userTests/test_user_profile_sethandle.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=516956098786, token='d28b9e1f0a6614f72b49570130f419c777db2b462249dc96d93031ea0bda1372', handleStr='')
ctx = None

    def testInvalidToken(userWoody, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           userProfileSethandle(userWoody.token, userWoody.handleStr, ctx)

httpTests/userTests/test_user_profile_sethandle.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:50: in userProfileSethandle
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________ testUserProfileSetnameValidName ________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=800475943444, token='d292aedb01412895c7ce9aefbde7e59207c0fc01f63dd70bfb972435d82b6e07', handleStr='')
ctx = None

    def testUserProfileSetnameValidName(userWoody, ctx):
        #  woody became japanese with family coming first
>       userProfileSetname(userWoody.token, userWoody.nameLast, userWoody.nameFirst, ctx)

httpTests/userTests/test_user_profile_setname.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:24: in userProfileSetname
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
______________________________ testInvalidName[-] ______________________________

nameFirst = '', nameLast = ''
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1619050134337, token='f0d2a0528286f6adf289c8ed9b03bc2afef1c25fde2790b2abfdf9ac4e8a031b', handleStr='')
ctx = None

    @pytest.mark.parametrize('nameFirst', ['', 'M' * 51])
    @pytest.mark.parametrize('nameLast', ['', 'P' * 51])
    def testInvalidName(nameFirst, nameLast, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetname(userWoody.token, nameFirst, nameLast, ctx)

httpTests/userTests/test_user_profile_setname.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:24: in userProfileSetname
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____ testInvalidName[-MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM] _____

nameFirst = 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM', nameLast = ''
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1356574676697, token='c21a07e7d41fc999a9afbd02f6de7418a1310d56ecfd7e3f281d6d41eda8dc13', handleStr='')
ctx = None

    @pytest.mark.parametrize('nameFirst', ['', 'M' * 51])
    @pytest.mark.parametrize('nameLast', ['', 'P' * 51])
    def testInvalidName(nameFirst, nameLast, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetname(userWoody.token, nameFirst, nameLast, ctx)

httpTests/userTests/test_user_profile_setname.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:24: in userProfileSetname
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
____ testInvalidName[PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP-] _____

nameFirst = '', nameLast = 'PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=341337783608, token='24d62b9008dd8cd0130c2ba62d8594f6f494edd413430df88f6ec654b2a18f8e', handleStr='')
ctx = None

    @pytest.mark.parametrize('nameFirst', ['', 'M' * 51])
    @pytest.mark.parametrize('nameLast', ['', 'P' * 51])
    def testInvalidName(nameFirst, nameLast, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetname(userWoody.token, nameFirst, nameLast, ctx)

httpTests/userTests/test_user_profile_setname.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:24: in userProfileSetname
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_ testInvalidName[PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP-MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM] _

nameFirst = 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM'
nameLast = 'PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP'
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1174558540185, token='acabd2b4ee6533c1c73e62a1af5e6e15b4cdd71614e5559970a2f34b1ea37569', handleStr='')
ctx = None

    @pytest.mark.parametrize('nameFirst', ['', 'M' * 51])
    @pytest.mark.parametrize('nameLast', ['', 'P' * 51])
    def testInvalidName(nameFirst, nameLast, userWoody, ctx):
        with pytest.raises(InputError):
>           userProfileSetname(userWoody.token, nameFirst, nameLast, ctx)

httpTests/userTests/test_user_profile_setname.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:24: in userProfileSetname
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
_______________________________ testInvalidToken _______________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1606918887146, token='3cc802c573e6880c8248a144052bb986d5495db8100f82e074cd0e820436b007', handleStr='')
ctx = None

    def testInvalidToken(userWoody, ctx):
        authLogout(userWoody.token, ctx)
        with pytest.raises(AccessError):
>           userProfileSetname(userWoody.token, userWoody.nameLast, userWoody.nameFirst, ctx)

httpTests/userTests/test_user_profile_setname.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:24: in userProfileSetname
    return util.parseResponse(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

res = <Response [404]>

    def parseResponse(res):
        if res.status_code in [200, 201]:
            return res.json()
        elif res.status_code == 400:
            raise error.InputError()
        elif res.status_code == 403:
            raise error.AccessError()
        else:
>           raise Exception(res)
E           Exception: <Response [404]>

httpTests/fakepi/util.py:97: Exception
___________________________ testReturnFormatCorrect ____________________________

userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=819119826164, token='3ceabd7d434487575efab6f3f326fd1624689263b7a4c602676d0975c1c1588c', handleStr='')
img = IMG(url='http://cgi.cse.unsw.edu.au/~jas/home/pics/jas.jpg', xmin=0, ymin=0, xmax=144, ymax=61)
ctx = None

    @iteration3
    def testReturnFormatCorrect(userWoody, img, ctx):
>       assert userProfileUploadphoto(userWoody.token, img.url, img.xmin, img.ymin, img.xmax, img.ymax, ctx) == {}

httpTests/userTests/test_user_profile_uploadphoto.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:76: in userProfileUploadphoto
    return util.parseResponse(
httpTests/fakepi/util.py:91: in parseResponse
    return res.json()
../../.local/lib/python3.9/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fca4c4051f0>, s = ''
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fca4efe61b0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
______________________ testInvalidDimensions[-1000-0-0-0] ______________________

xminDiff = -1000, ymaxDiff = 0, xmaxDiff = 0, yminDiff = 0
userWoody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', nameFirst='sheriff', nameLast='woody', uId=1245376432535, token='33228b827cd8c36544e84626844b4eaf209bfb5ed8144bc1930227c57fae6d8c', handleStr='')
img = IMG(url='http://cgi.cse.unsw.edu.au/~jas/home/pics/jas.jpg', xmin=0, ymin=0, xmax=144, ymax=61)
ctx = None

    @iteration3
    @pytest.mark.parametrize('xminDiff, yminDiff, xmaxDiff, ymaxDiff', [
        (-1000, 0, 0, 0),
        (0, -1000, 0, 0),
        (0, 0, -1000, 0),
        (0, 0, 0, -1000),
    ])
    def testInvalidDimensions(xminDiff, ymaxDiff, xmaxDiff, yminDiff, userWoody, img, ctx):
        with pytest.raises(InputError):
            if xminDiff == yminDiff == xmaxDiff == ymaxDiff == 0:
                raise InputError('lol this actually is valid')
            else:
>               userProfileUploadphoto(
                    userWoody.token,
                    img.url,
                    img.xmin + xminDiff,
                    img.ymin + yminDiff,
                    img.xmax + xmaxDiff,
                    img.ymax + ymaxDiff,
                    ctx
                )

httpTests/userTests/test_user_profile_uploadphoto.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
httpTests/fakepi/user.py:76: in userProfileUploadphoto
    return util.parseResponse(
httpTests/fakepi/util.py:91: in parseResponse
    return res.json()
../../.local/lib/python3.9/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/usr/lib/python3/dist-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/usr/lib/python3/dist-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fca4c4051f0>, s = ''
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fca4efe61b0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3/dist-packages/simplejson/decoder.py:400: JSONDecodeError
=============================== warnings summary ===============================
../../../../../../usr/lib/python3/dist-packages/blinker/base.py:93
  /usr/lib/python3/dist-packages/blinker/base.py:93: DeprecationWarning: invalid escape sequence \*
    """Connect *receiver* to signal events sent by *sender*.

../../../../../../usr/lib/python3/dist-packages/blinker/base.py:161
  /usr/lib/python3/dist-packages/blinker/base.py:161: DeprecationWarning: invalid escape sequence \*
    """Connect the decorated function as a receiver for *sender*.

../../../../../../usr/lib/python3/dist-packages/blinker/base.py:242
  /usr/lib/python3/dist-packages/blinker/base.py:242: DeprecationWarning: invalid escape sequence \*
    """Emit this signal on behalf of *sender*, passing on \*\*kwargs.

-- Docs: https://docs.pytest.org/en/stable/warnings.html
=========================== short test summary info ============================
FAILED httpTests/adminTests/test_admin_user_remove.py::testOnceRemovedUserCantDoAnything
FAILED httpTests/adminTests/test_admin_user_remove.py::testMessagesAfterUserRemovalCorrectFormat
FAILED httpTests/adminTests/test_admin_user_remove.py::testRemovedProfileStillFetchableWithUserProfile
FAILED httpTests/adminTests/test_admin_user_remove.py::testRemovalRemovedFromChannel
FAILED httpTests/adminTests/test_admin_user_remove.py::testRemovalRemovedFromDm
FAILED httpTests/adminTests/test_admin_user_remove.py::testRemovalNotInUsersAll
FAILED httpTests/adminTests/test_admin_user_remove.py::testEmailReusable - ht...
FAILED httpTests/adminTests/test_admin_user_remove.py::testHandleReusable - h...
FAILED httpTests/adminTests/test_admin_user_remove.py::testInvalidUser - http...
FAILED httpTests/adminTests/test_admin_user_remove.py::testCannotRemoveLastOwner
FAILED httpTests/adminTests/test_admin_userpermission_change.py::testSuccessfulPermissionChange
FAILED httpTests/adminTests/test_admin_userpermission_change.py::testCannotDemoteLastOwner
FAILED httpTests/adminTests/test_admin_userpermission_change.py::testInvalidUser
FAILED httpTests/adminTests/test_admin_userpermission_change.py::testInvalidPermission
FAILED httpTests/adminTests/test_admin_userpermission_change.py::testSamePermission
FAILED httpTests/authTests/test_auth_login.py::testCanHaveTwoSessions - Excep...
FAILED httpTests/authTests/test_auth_register.py::testRemovedUserName - Excep...
FAILED httpTests/authTests/test_auth_register.py::testSuccessfulRegistration
FAILED httpTests/authTests/test_auth_register.py::testBasicHandleGeneratedCorrectly[Bob-Smith-bobsmith]
FAILED httpTests/authTests/test_auth_register.py::testBasicHandleGeneratedCorrectly[ababababab-cdcdcdcdcdcd-abababababcdcdcdcdcd]
FAILED httpTests/authTests/test_auth_register.py::testDuplicateHandlesGeneratedCorrectly[abcdefghij-klmnopqrs-abcdefghijklmnopqrs-abcdefghij-klmnopqrs-abcdefghijklmnopqrs0]
FAILED httpTests/authTests/test_auth_register.py::testDuplicateHandlesGeneratedCorrectly[abcdefghij-klmnopqrst-abcdefghijklmnopqrst-abcdefghij-klmnopqrst-abcdefghijklmnopqrst0]
FAILED httpTests/authTests/test_auth_register.py::testDuplicateHandlesGeneratedCorrectly[@bcdefgh!j-klmn opqrst-bcdefghjklmnopqrst-bcdefghj-klmnopqrst-bcdefghjklmnopqrst0]
FAILED httpTests/authTests/test_auth_register.py::testDuplicateHandlesGeneratedCorrectly[abc-def0-abcdef0-abc-def-abcdef1]
FAILED httpTests/authTests/test_passwordreset_request.py::testReturnFormatCorrect
FAILED httpTests/authTests/test_passwordreset_request.py::testPasswordRequestLogsOutEverywhere
FAILED httpTests/channelTests/test_channel_addowner.py::testChannelOwnerCanAddownerWhenMember
FAILED httpTests/channelTests/test_channel_addowner.py::testNonMemberCannotAddOwner
FAILED httpTests/channelTests/test_channel_addowner.py::testGlobalOwnerNonMemberCantAddownerPrivate
FAILED httpTests/channelTests/test_channel_addowner.py::testGlobalOwnerNonMemberCantAddownerPublic
FAILED httpTests/channelTests/test_channel_details.py::testMemberSuccessful
FAILED httpTests/channelTests/test_channel_details.py::testNonMemberNotSuccessful
FAILED httpTests/channelTests/test_channel_details.py::testInvalidChannelId
FAILED httpTests/channelTests/test_channel_details.py::testInvalidToken - Exc...
FAILED httpTests/channelTests/test_channel_invite.py::testDuplicateInvite - E...
FAILED httpTests/channelTests/test_channel_invite.py::testInviteGlobalOwner
FAILED httpTests/channelTests/test_channel_invite.py::testInviteGlobalMember
FAILED httpTests/channelTests/test_channel_invite.py::testInvitationFromNonChannelMember
FAILED httpTests/channelTests/test_channel_invite.py::testChannelIdInvalid - ...
FAILED httpTests/channelTests/test_channel_invite.py::testUIdInvalid - Except...
FAILED httpTests/channelTests/test_channel_invite.py::testInvalidatedToken - ...
FAILED httpTests/channelTests/test_channel_join.py::testGlobalOwnerJoinChannelPublic
FAILED httpTests/channelTests/test_channel_join.py::testGlobalOwnerJoinChannelPrivate
FAILED httpTests/channelTests/test_channel_join.py::testGlobalMemberJoinPublic
FAILED httpTests/channelTests/test_channel_leave.py::testMemberLeaveChannelSuccessfully
FAILED httpTests/channelTests/test_channel_leave.py::testLeaveChannelWhenNotMember
FAILED httpTests/channelTests/test_channel_leave.py::testInvalidChannelId - E...
FAILED httpTests/channelTests/test_channel_leave.py::testInvalidToken - Excep...
FAILED httpTests/channelTests/test_channel_messages.py::testMessageTimestamp
FAILED httpTests/channelTests/test_channel_messages.py::testUnderFiftyMessagesSent
FAILED httpTests/channelTests/test_channel_messages.py::testOverFiftyMessagesSent
FAILED httpTests/channelTests/test_channel_messages.py::testRemovalByEditReflected
FAILED httpTests/channelTests/test_channel_messages.py::testRemovalByDeletionReflected
FAILED httpTests/channelTests/test_channel_messages.py::testInputErrorWhenStartGreaterThanMessageNum
FAILED httpTests/channelTests/test_channel_messages.py::testAccessErrorWhenUserIsNonMember
FAILED httpTests/channelTests/test_channel_messages.py::testInputErrorWhenChannelIdInvalid
FAILED httpTests/channelTests/test_channel_messages.py::testAccessErrorWhenInvalidTokenGiven
FAILED httpTests/channelTests/test_channel_removeowner.py::testOwnerCanRemoveOwner
FAILED httpTests/channelTests/test_channel_removeowner.py::testGlobalOwnerMmberCanRemoveOwner
FAILED httpTests/channelTests/test_channel_removeowner.py::testGlobalOwnerNonmemberCannotRemoveOwner
FAILED httpTests/channelTests/test_channel_removeowner.py::testNonmemberCannotRemoveOwner
FAILED httpTests/channelTests/test_channel_removeowner.py::testMmberCannotRemoveOwner
FAILED httpTests/channels_tests/test_channels_create.py::testCreateChannel[True-andys room]
FAILED httpTests/channels_tests/test_channels_create.py::testCreateChannel[False-andys room]
FAILED httpTests/channels_tests/test_channels_list.py::testListAfterLeaveChannel
FAILED httpTests/dmTests/test_dm_create.py::testDmNameCreationMultiple - asse...
FAILED httpTests/dmTests/test_dm_details.py::testMemberSuccessful - Assertion...
FAILED httpTests/dmTests/test_dm_messages.py::testRemovalByEditReflected - Ex...
FAILED httpTests/dmTests/test_dm_messages.py::testRemovalByDeletionReflected
FAILED httpTests/messageTests/test_message_edit.py::testOriginalPosterCanEditMessageChannel
FAILED httpTests/messageTests/test_message_edit.py::testOriginalPosterCanEditMessageDm
FAILED httpTests/messageTests/test_message_edit.py::testGlobalOwnerCantEditMembersMessageDm
FAILED httpTests/messageTests/test_message_edit.py::testEmptyEditDeletesMessage
FAILED httpTests/messageTests/test_message_edit.py::testInvalidMessageLength
FAILED httpTests/messageTests/test_message_edit.py::testCannotEditDeletedMessage
FAILED httpTests/messageTests/test_message_edit.py::testNonownerNonposterCantEdit
FAILED httpTests/messageTests/test_message_edit.py::testInvalidToken - Except...
FAILED httpTests/messageTests/test_message_meta.py::testMessageIdsUnique - Ex...
FAILED httpTests/messageTests/test_message_meta.py::testMessageIdsUniqueIter3
FAILED httpTests/messageTests/test_message_pin.py::testSuccessfulPinChannelOwnerInChannel
FAILED httpTests/messageTests/test_message_pin.py::testSuccessfulPinGlobalOwnerInChannel
FAILED httpTests/messageTests/test_message_pin.py::testCannotPinTwice - Excep...
FAILED httpTests/messageTests/test_message_pin.py::testChannelMemberCantPin
FAILED httpTests/messageTests/test_message_pin.py::testNonmemberCantPin - Exc...
FAILED httpTests/messageTests/test_message_pin.py::testInvalidToken - Excepti...
FAILED httpTests/messageTests/test_message_react.py::testSuccessfulReactInChannel
FAILED httpTests/messageTests/test_message_react.py::testInvalidReactId - Exc...
FAILED httpTests/messageTests/test_message_react.py::testCantReactTwice - Exc...
FAILED httpTests/messageTests/test_message_react.py::testNonmemberCannotReact
FAILED httpTests/messageTests/test_message_react.py::testInvalidToken - Excep...
FAILED httpTests/messageTests/test_message_remove.py::testOriginalPosterCanRemoveMessage
FAILED httpTests/messageTests/test_message_remove.py::testGlobalOwnerCantRemoveMembersMessageDm
FAILED httpTests/messageTests/test_message_remove.py::testCannotRemoveDeletedMessage
FAILED httpTests/messageTests/test_message_remove.py::testNonownerNonposterCantRemoveMessage
FAILED httpTests/messageTests/test_message_remove.py::testInvalidToken - Exce...
FAILED httpTests/messageTests/test_message_send.py::testValidMessage - Except...
FAILED httpTests/messageTests/test_message_send.py::testNonmemberPost - Excep...
FAILED httpTests/messageTests/test_message_send.py::testInvalidChannel - Exce...
FAILED httpTests/messageTests/test_message_send.py::testInvalidMessage[] - Ex...
FAILED httpTests/messageTests/test_message_send.py::testInvalidMessage[mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm]
FAILED httpTests/messageTests/test_message_send.py::testInvalidToken - Except...
FAILED httpTests/messageTests/test_message_sendlater.py::testValidFutureMessage
FAILED httpTests/messageTests/test_message_sendlater.py::testReturnsImmediately
FAILED httpTests/messageTests/test_message_sendlater.py::testInvalidReturnedIdUntilSent
FAILED httpTests/messageTests/test_message_sendlater.py::testInvalidToken - h...
FAILED httpTests/messageTests/test_message_sendlaterdm.py::testInvalidReturnedIdUntilSent
FAILED httpTests/messageTests/test_message_sendlaterdm.py::testInvalidToken
FAILED httpTests/messageTests/test_message_share.py::testSuccessfulShareToChannel
FAILED httpTests/messageTests/test_message_share.py::testSuccessfulCrossShare[True]
FAILED httpTests/messageTests/test_message_share.py::testSuccessfulCrossShare[False]
FAILED httpTests/messageTests/test_message_share.py::testCannotShareToUnjoinedDm
FAILED httpTests/messageTests/test_message_share.py::testCannotShareToUnjoinedChannel
FAILED httpTests/messageTests/test_message_share.py::testCannotShareFromUnjoinedChannel
FAILED httpTests/messageTests/test_message_share.py::testInvalidMessageLength
FAILED httpTests/messageTests/test_message_share.py::testShareToInvalidDmId
FAILED httpTests/messageTests/test_message_share.py::testInvalidToken - Excep...
FAILED httpTests/messageTests/test_message_unpin.py::testSuccessfulUnpinChannelOwnerInChannel
FAILED httpTests/messageTests/test_message_unpin.py::testSuccessfulUnpinGlobalOwnerInChannel
FAILED httpTests/messageTests/test_message_unpin.py::testCannotUnpinTwice - E...
FAILED httpTests/messageTests/test_message_unpin.py::testChannelMemberCantUnpin
FAILED httpTests/messageTests/test_message_unpin.py::testNonmemberCantUnpin
FAILED httpTests/messageTests/test_message_unpin.py::testInvalidToken - Excep...
FAILED httpTests/messageTests/test_message_unreact.py::testSuccessfulUnreactInChannel
FAILED httpTests/messageTests/test_message_unreact.py::testInvalidReactId - E...
FAILED httpTests/messageTests/test_message_unreact.py::testCantUnreactTwice
FAILED httpTests/messageTests/test_message_unreact.py::testNonmemberCannotUnreact
FAILED httpTests/messageTests/test_message_unreact.py::testInvalidToken - Exc...
FAILED httpTests/otherTests/test_clear.py::testClearWorks - Exception: <Respo...
FAILED httpTests/otherTests/test_notifications_get.py::testTagThruMessageSendTriggersNotification
FAILED httpTests/otherTests/test_notifications_get.py::testTagNotInChannel - ...
FAILED httpTests/otherTests/test_notifications_get.py::testMultipleSameTagsOnlyOneNotification
FAILED httpTests/otherTests/test_notifications_get.py::testTagSelf - Exceptio...
FAILED httpTests/otherTests/test_notifications_get.py::testMultipleTags - Exc...
FAILED httpTests/otherTests/test_notifications_get.py::testTagThruMessageSenddmTriggersNotification
FAILED httpTests/otherTests/test_notifications_get.py::testTagThruMessageEditTriggersNotification
FAILED httpTests/otherTests/test_notifications_get.py::testTagThruMessageShareTriggersNotification
FAILED httpTests/otherTests/test_notifications_get.py::testTagThruMessageSendlaterTriggersNotification
FAILED httpTests/otherTests/test_notifications_get.py::testMessageSendlaterTagNotifiesWhenSent
FAILED httpTests/otherTests/test_notifications_get.py::testTagThruMessageSendlaterdmTriggersNotification
FAILED httpTests/otherTests/test_notifications_get.py::testTagNotificationMessagePreviewLength[a small message]
FAILED httpTests/otherTests/test_notifications_get.py::testTagNotificationMessagePreviewLength[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA]
FAILED httpTests/otherTests/test_notifications_get.py::testReactTriggersNotification[ch]
FAILED httpTests/otherTests/test_notifications_get.py::testReactTriggersNotification[dm]
FAILED httpTests/otherTests/test_notifications_get.py::testAddThruChInviteTriggersNotification
FAILED httpTests/otherTests/test_notifications_get.py::testAddThruDmCreateTriggersNotification
FAILED httpTests/otherTests/test_notifications_get.py::testMostRecent_20NotificationsFetched
FAILED httpTests/otherTests/test_search.py::testSingleMatch - Exception: <Res...
FAILED httpTests/otherTests/test_search.py::testCaseInsensitiveMatch - Except...
FAILED httpTests/otherTests/test_search.py::testMultipleMatches - Exception: ...
FAILED httpTests/otherTests/test_search.py::testMultipleChannelsJoined - Exce...
FAILED httpTests/otherTests/test_search.py::testSearchIncludesOnlyJoinedChannels
FAILED httpTests/otherTests/test_search.py::testSearchMatchesMoreThanJustAuthorisedUser
FAILED httpTests/otherTests/test_users_all.py::testSuccessfulUsersAll - Excep...
FAILED httpTests/otherTests/test_users_all.py::testInvalidToken - Exception: ...
FAILED httpTests/standupTests/test_standup_active.py::testCorrectReturnFormat[True]
FAILED httpTests/standupTests/test_standup_send.py::testMessagesBufferedAndDisplayedCorrectly
FAILED httpTests/standupTests/test_standup_send.py::testStandupSendsAfterLoggedOut
FAILED httpTests/standupTests/test_standup_start.py::testStandupNoMessages - ...
FAILED httpTests/standupTests/test_standup_start.py::testStandupRestartableAfterLapse
FAILED httpTests/statsTests/test_user_stats.py::testReturnTypeCorrect - KeyEr...
FAILED httpTests/statsTests/test_user_stats.py::testChannelsTrackedChannelInvite
FAILED httpTests/statsTests/test_user_stats.py::testChannelsTrackedChannelLeave
FAILED httpTests/statsTests/test_user_stats.py::testSmsTrackedSmCreate - KeyE...
FAILED httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageSend
FAILED httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageSendlater
FAILED httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageShare
FAILED httpTests/statsTests/test_users_stats.py::testReturnTypeCorrect - Asse...
FAILED httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageSend
FAILED httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageSendlater
FAILED httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageSenddmlater
FAILED httpTests/statsTests/test_users_stats.py::testMessagesTrackedMessageShare
FAILED httpTests/statsTests/test_users_stats.py::testMessagesTrackedEditedToRemoval
FAILED httpTests/statsTests/test_users_stats.py::testMessagesTrackedDeleted
FAILED httpTests/statsTests/test_users_stats.py::testMessagesTrackedDmRemoved
FAILED httpTests/userTests/test_user_profile.py::testUserProfileValid - Excep...
FAILED httpTests/userTests/test_user_profile.py::testInvalidUser - Exception:...
FAILED httpTests/userTests/test_user_profile.py::testInvalidToken - Exception...
FAILED httpTests/userTests/test_user_profile_setemail.py::testSuccessfulEmailChange
FAILED httpTests/userTests/test_user_profile_setemail.py::testCannotChangeToTakenEmail
FAILED httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[]
FAILED httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[bob]
FAILED httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[ab.com]
FAILED httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[@gmail.com]
FAILED httpTests/userTests/test_user_profile_setemail.py::testInvalidEmail[ab@ab@gmail.com]
FAILED httpTests/userTests/test_user_profile_setemail.py::testInvalidToken - ...
FAILED httpTests/userTests/test_user_profile_sethandle.py::testSuccessfulHandleChange
FAILED httpTests/userTests/test_user_profile_sethandle.py::testCannotChangeToTakenHandle
FAILED httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[]
FAILED httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[a]
FAILED httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[aa]
FAILED httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[aaaaaaaaaaaaaaaaaaaaa]
FAILED httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[new handle]
FAILED httpTests/userTests/test_user_profile_sethandle.py::testInvalidHandle[newh@ndle]
FAILED httpTests/userTests/test_user_profile_sethandle.py::testInvalidToken
FAILED httpTests/userTests/test_user_profile_setname.py::testUserProfileSetnameValidName
FAILED httpTests/userTests/test_user_profile_setname.py::testInvalidName[-]
FAILED httpTests/userTests/test_user_profile_setname.py::testInvalidName[-MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]
FAILED httpTests/userTests/test_user_profile_setname.py::testInvalidName[PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP-]
FAILED httpTests/userTests/test_user_profile_setname.py::testInvalidName[PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP-MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]
FAILED httpTests/userTests/test_user_profile_setname.py::testInvalidToken - E...
FAILED httpTests/userTests/test_user_profile_uploadphoto.py::testReturnFormatCorrect
FAILED httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidDimensions[-1000-0-0-0]
ERROR httpTests/statsTests/test_user_stats.py::testSmsTrackedSmLeave
ERROR httpTests/statsTests/test_user_stats.py::testSmsTrackedSmRemove
ERROR httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageSenddm
ERROR httpTests/statsTests/test_user_stats.py::testMessagesTrackedMessageSenddmlater
ERROR httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidDimensions[0--1000-0-0]
ERROR httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidDimensions[0-0--1000-0]
ERROR httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidDimensions[0-0-0--1000]
ERROR httpTests/userTests/test_user_profile_uploadphoto.py::testXEndLessThanStartValue
ERROR httpTests/userTests/test_user_profile_uploadphoto.py::testYEndLessThanStartValue
ERROR httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidUrl - ...
ERROR httpTests/userTests/test_user_profile_uploadphoto.py::testInvalidToken
====== 202 failed, 153 passed, 3 warnings, 11 errors in 66.08s (0:01:06) =======
